<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Andreas Nicolai">
<title>OpenGL + Qt Tutorial</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */

@import url(https://fonts.googleapis.com/css?family=Roboto+Condensed);
@import url(https://asciidoctor.org/stylesheets/asciidoctor.css); /* Default asciidoc style framework - important */

/* CUSTOMISATIONS */
/* Change the values in root for quick customisation. If you want even more fine grain... venture further. */

:root{
--maincolor:#FFFFFF;
--primarycolor:#a90e22;
--secondarycolor:#333333;
--tertiarycolor: #772953;
--sidebarbackground:#CCC;
--linkcolor:#b71c1c;
--linkcoloralternate:#f44336;
--white:#FFFFFF;
--black:#000000;
}

/* Text styles */
body{font-family: "Roboto Condensed",sans-serif;}

h1,h2{color:var(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;}
h3,h4,h5,h6{color:var(--secondarycolor);font-family: "Roboto Condensed",sans-serif;}
.title{color:(--primarycolor) !important;font-family:"Roboto Condensed",sans-serif;font-style: normal; font-weight: normal;}
p{font-family: "Roboto Condensed",sans-serif ! important}
#toc.toc2 a{font-family:"Roboto Condensed",sans-serif;}
/*#toc.toc2 a:link{color:(--linkcolor) !important}
a:visited {color: #ffdbad;}
a.bare:visited {color: #204f83;}
a:hover {color: #317ed4;}
#toc.toc2 a:hover {color: #f1b464;}*/
/* code{background-color: var(--secondarycolor) !important;color:var(--white)} */
code,kbd,pre,samp{font-family:monospace;font-size:0.8em}

/* Table styles */
th{background-color: var(--tertiarycolor);color:var(--white) !important;}

#toctitle{color:var(--primarycolor);font-family: "Roboto Condensed",sans-serif;font-size: 1.6875em;}
#toc.toc2{background-color:#f4f8fd;}
/*#toc.toc2{background-color:#2C001E;color:white;}
#toc.toc2.a{color:white;}
*/

/* Responsiveness fixes */
video {
  max-width: 100%;
}

@media all and (max-width: 600px) {
table {
  width: 55vw!important;
  font-size: 3vw;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>OpenGL + Qt Tutorial</h1>
<div class="details">
<span id="author" class="author">Andreas Nicolai</span><br>
<span id="email" class="email"><a href="mailto:andreas.nicolai@tu-dresden.de">andreas.nicolai@tu-dresden.de</a></span><br>
<span id="revnumber">version 0.1.0,</span>
<span id="revdate">März 2020</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Inhaltsverzeichnis</div>
<ul class="sectlevel1">
<li><a href="#_einführung">Einführung</a>
<ul class="sectlevel2">
<li><a href="#_kernthemen">Kernthemen</a></li>
<li><a href="#_plattformunterstützung_und_opengl_version">Plattformunterstützung und OpenGL-Version</a></li>
<li><a href="#_grundlagen">Grundlagen</a></li>
</ul>
</li>
<li><a href="#_tutorial_01_opengl_innerhalb_eines_qwindow">1. Tutorial 01: OpenGL innerhalb eines QWindow</a>
<ul class="sectlevel2">
<li><a href="#_qwidget_näher_betrachtet">1.1. QWidget näher betrachtet</a></li>
<li><a href="#_allgemeingültige_basisklasse_für_opengl_render_fenster">1.2. Allgemeingültige Basisklasse für OpenGL-Render-Fenster</a>
<ul class="sectlevel3">
<li><a href="#_initialisierung_des_opengl_fensters">1.2.1. Initialisierung des OpenGL-Fensters</a></li>
</ul>
</li>
<li><a href="#_implementierung_eines_konkreten_renderfensters">1.3. Implementierung eines konkreten Renderfensters</a>
<ul class="sectlevel3">
<li><a href="#_shaderprogramme">1.3.1. Shaderprogramme</a></li>
<li><a href="#_vertex_buffer_objekte_vbo_und_vertex_array_objekte_vba">1.3.2. Vertex-Buffer-Objekte (VBO) und Vertex-Array-Objekte (VBA)</a></li>
<li><a href="#_rendern">1.3.3. Rendern</a></li>
<li><a href="#_resourcenfreigabe">1.3.4. Resourcenfreigabe</a></li>
</ul>
</li>
<li><a href="#_das_hauptprogramm">1.4. Das Hauptprogramm</a></li>
</ul>
</li>
<li><a href="#_tutorial_02_alternative_die_klasse_qopenglwindow">2. Tutorial 02: Alternative: die Klasse QOpenGLWindow</a>
<ul class="sectlevel2">
<li><a href="#_verwendung_der_klasse">2.1. Verwendung der Klasse</a></li>
<li><a href="#_die_implementierung_der_klasse_qopenglwindow">2.2. Die Implementierung der Klasse QOpenGLWindow</a>
<ul class="sectlevel3">
<li><a href="#_constructor">2.2.1. Constructor</a></li>
<li><a href="#_ereignisbehandlungsroutinen">2.2.2. Ereignisbehandlungsroutinen</a></li>
<li><a href="#_initialisierung">2.2.3. Initialisierung</a></li>
</ul>
</li>
<li><a href="#_zeichnen_mit_index_elementpuffern">2.3. Zeichnen mit Index-/Elementpuffern</a>
<ul class="sectlevel3">
<li><a href="#_shaderprogramm">2.3.1. Shaderprogramm</a></li>
<li><a href="#_initialisierung_von_gemischten_vertex_puffern">2.3.2. Initialisierung von gemischten Vertex-Puffern</a></li>
<li><a href="#_element_indexpuffer">2.3.3. Element-/Indexpuffer</a></li>
<li><a href="#_attribute_im_gemischten_vertexarray">2.3.4. Attribute im gemischten Vertexarray</a></li>
<li><a href="#_freigabe_der_puffer">2.3.5. Freigabe der Puffer</a></li>
<li><a href="#_rendern_2">2.3.6. Rendern</a></li>
</ul>
</li>
<li><a href="#_zusammenfassung">2.4. Zusammenfassung</a></li>
</ul>
</li>
<li><a href="#_tutorial_03_renderfenster_in_einem_qdialog_eingebettet">3. Tutorial 03: Renderfenster in einem QDialog eingebettet</a>
<ul class="sectlevel2">
<li><a href="#_window_container_widgets">3.1. Window Container Widgets</a></li>
<li><a href="#_interaktion_und_synchronisation_mit_dem_zeichnen">3.2. Interaktion und Synchronisation mit dem Zeichnen</a>
<ul class="sectlevel3">
<li><a href="#_einmalige_änderungen_farbwechsel_auf_knopfdruck">3.2.1. Einmalige Änderungen: Farbwechsel auf Knopfdruck</a></li>
<li><a href="#_animierte_farbänderung">3.2.2. Animierte Farbänderung</a></li>
<li><a href="#_zusammenfassung_2">3.2.3. Zusammenfassung</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_04_verwendung_des_qopenglwidget">4. Tutorial 04: Verwendung des QOpenGLWidget</a>
<ul class="sectlevel2">
<li><a href="#_was_bietet_das_qopenglwidget">4.1. Was bietet das QOpenGLWidget</a>
<ul class="sectlevel3">
<li><a href="#_anpassung_der_vererbungshierarchie">4.1.1. Anpassung der Vererbungshierarchie</a></li>
<li><a href="#_initialisierung_2">4.1.2. Initialisierung</a></li>
<li><a href="#_einbettung_in_ein_anderes_qwidget">4.1.3. Einbettung in ein anderes QWidget</a></li>
</ul>
</li>
<li><a href="#_performance_vergleich">4.2. Performance-Vergleich</a></li>
<li><a href="#_transparenz">4.3. Transparenz</a>
<ul class="sectlevel3">
<li><a href="#_mit_qopenglwidget">4.3.1. Mit QOpenGLWidget</a></li>
<li><a href="#_mit_qwindow_basierten_opengl_renderfenstern">4.3.2. Mit QWindow-basierten OpenGL Renderfenstern</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_tutorial_05_maus_und_tastatureingaben">5. Tutorial 05: Maus- und Tastatureingaben</a>
<ul class="sectlevel2">
<li><a href="#_überblick">5.1. Überblick</a></li>
<li><a href="#_fenster_basisklasse_openglwindow">5.2. Fenster-Basisklasse OpenGLWindow</a></li>
<li><a href="#_klasse_sceneview_die_konkrete_implementierung">5.3. Klasse SceneView - die konkrete Implementierung</a>
<ul class="sectlevel3">
<li><a href="#_klassendeklaration">5.3.1. Klassendeklaration</a></li>
<li><a href="#_das_aktualisierungskonzept">5.3.2. Das Aktualisierungskonzept</a></li>
<li><a href="#_verwendung_der_klasse_sceneview">5.3.3. Verwendung der Klasse <em>SceneView</em></a></li>
<li><a href="#_implementierung_der_klasse_sceneview">5.3.4. Implementierung der Klasse <em>SceneView</em></a></li>
<li><a href="#_opengl_initialisierung">5.3.5. OpenGL-Initialisierung</a></li>
</ul>
</li>
<li><a href="#_tastatur_und_mauseingabe">5.4. Tastatur- und Mauseingabe</a></li>
<li><a href="#_shaderprogramme_2">5.5. Shaderprogramme</a></li>
<li><a href="#_transformationsmatrizen_und_kamera">5.6. Transformationsmatrizen und Kamera</a>
<ul class="sectlevel3">
<li><a href="#_transformationen">5.6.1. Transformationen</a></li>
<li><a href="#_aktualisierung_der_world2view_matrix">5.6.2. Aktualisierung der World2View Matrix</a></li>
</ul>
</li>
<li><a href="#_zeichenobjekte">5.7. Zeichenobjekte</a>
<ul class="sectlevel3">
<li><a href="#_effizientes_zeichnen_großer_geometrien">5.7.1. Effizientes Zeichnen großer Geometrien</a></li>
<li><a href="#_verwaltung_von_zeichenobjekten">5.7.2. Verwaltung von Zeichenobjekten</a></li>
<li><a href="#_zeichenobjekt_1_gitterraster_in_x_z_ebene">5.7.3. Zeichenobjekt #1: Gitterraster in X-Z Ebene</a></li>
<li><a href="#_gitter_mit_abblendung_in_der_tiefe">5.7.4. Gitter mit Abblendung in der Tiefe</a></li>
</ul>
</li>
<li><a href="#_antialiasing">5.8. Antialiasing</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_einführung">Einführung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dieses Tutorial ist <strong><em>kein</em></strong> OpenGL Tutorial. Man sollte also OpenGL selbst schon ganz gut kennen. Natürlich kann man die hier vorgestellten Beispiele als Vorlage nehmen, aber es geht hier wirklich darum, die Qt-Klassen und vorbereitete Funktionalität zu verstehen und sinnvoll zu nutzen.</p>
</div>
<div class="paragraph">
<p>Diese Anleitung soll auch <strong><em>nicht</em></strong> zeigen, wie man mit Qt ein Spiel- oder eine Spieleengine schreibt. Es geht eher um technische Anwendungen, in denen <em>Animationen keine Rolle spielen</em>. Fokus liegt eher darauf, effizient und resourcenschonend (und damit Laptop-Akku-schonend) 3D Grafik zu verwenden.</p>
</div>
<div class="paragraph">
<p>Es gibt eine PDF-Version des Tutorials:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/raw/master/docs/OpenGLQtTutorial.pdf" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial/raw/master/docs/OpenGLQtTutorial.pdf</a></p>
</div>
<div class="paragraph">
<p>Die Quelltexte (und Inhalte dieses Tutorials) liegen auf github:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial</a></p>
</div>
<div class="paragraph">
<p>Fragen und Anregungen kann man in der Issues-Seite auf Githab eintragen, die kann man ja wie ein Diskussionsforum verwenden, nur dass die nie geschlossen werden :-)</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/issues" class="bare">https://github.com/ghorwin/OpenGLWithQt-Tutorial/issues</a></p>
</div>
<div class="sect2">
<h3 id="_kernthemen">Kernthemen</h3>
<div class="paragraph">
<p>In diesem Tutorial geht es primär um folgende Themen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integration von OpenGL in eine Qt Widget Anwendung (es werden verschiedene Ansätze diskutiert), einschließlich Fehlerbehandlung</p>
</li>
<li>
<p>Verwendung der Qt-Wrapper-Klassen als Ersatz für native OpenGL Aufrufe (die Dokumentation vieler OpenGL-Qt-Klassen ist bisweilen etwas dürftig)</p>
</li>
<li>
<p>Implementierung von Keyboard- und Maussteuerung</p>
</li>
<li>
<p>Rendering-on-Demand mit Fokus auf CAD/Virtual Design Anwendungen, d.h. batterieschonendes Rendern nur, wenn sich Camera oder Scene ändern</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es wird eine hinreichend aktuelle Qt-Version vorausgesetzt, mindestens <strong>Qt 5.4</strong>. Bei meinem Ubuntu 18.04 System ist Qt 5.9 dabei, das dürfte also eine gute Basisversion für dieses Tutorial sein. Funktionen neuerer Qt Versionen betrachte ich nicht.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Qt enthält aus Kompatibilitätsgründen noch eine Reihe von OpenGL-Implementierungsklassen (im OpenGL Modul), welche alle mit <code>QGL...</code> beginnen. Diese sind veraltet und sollten in neuen Programmen nicht mehr verwendet werden. In aktuellen Qt Programmen sind die Hilfsklassen für OpenGL-Fenster im GUI-Modul enthalten.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_plattformunterstützung_und_opengl_version">Plattformunterstützung und OpenGL-Version</h3>
<div class="paragraph">
<p>Das Tutorial addressiert Desktopanwendungen, d.h. <em>Linux</em>, <em>Windows</em> und <em>MacOS</em> Widgets-Anwendungen. Daher ist OpenGL ES (ES für Embedded Systems) kein Thema für dieses Tutorial. Das Wesentliche sollte aber übertragbar sein.</p>
</div>
<div class="paragraph">
<p>Hinsichtlich der OpenGL-Version wird Mac-bedingt Version 3.3 angepeilt. Hinsichtlich der Einbettung von OpenGL in Qt Widgets-Anwendungen spielt die OpenGL-Version eigentlich keine Rolle.</p>
</div>
<div class="paragraph">
<p>Im Rahmen dieses Tutorials wird für die Beispiele das Qt bzw. qmake Buildsystem verwendet. Das Thema <em>Compilieren mit CMake</em> und <em>Deployment von OpenGL-basierten Anwendungen</em> wird in einem speziellen Tutorial erklärt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_grundlagen">Grundlagen</h3>
<div class="paragraph">
<p>Als Einstieg in OpenGL empfehle ich folgende (englischsprachige) Webseiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learnopengl.com" class="bare">https://learnopengl.com</a> : ein gutes und aktuelles Tutorial mit guten Abbildungen und guter Mischung aus C++ und C, eine Lektüre der ersten paar Kapitel dieses Tutorials sollte eigentlich ausreichen, um alle in meinem Tutorial verwendeten OpenGL-Befehle und Techniken zu verstehen.</p>
</li>
<li>
<p><a href="http://antongerdelan.net/opengl" class="bare">http://antongerdelan.net/opengl</a> : englisch, gute Illustrationen und Erklärungen zu einzelnen Themen</p>
</li>
<li>
<p><a href="http://www.opengl-tutorial.org" class="bare">http://www.opengl-tutorial.org</a> : eher grundlegendes Tutorialset, C und GLUT werden verwendet</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mein Tutorial selbst basiert zum Teil auf folgenden Webtutorials:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.trentreed.net/blog/qt5-opengl-part-0-creating-a-window" class="bare">https://www.trentreed.net/blog/qt5-opengl-part-0-creating-a-window</a> : in diesem Tutorial und den Forumkommentaren gibt es einige Anregungen, allerdings ist dies eher eine Dokumentation eigener Versuche grafisch optimale Effekte zu erziehlen. Es gibt durchaus interessante Anregungen. Manche Quelltextumsetzung sind nicht ganz optimal, daher mit Vorsicht als Vorlage für eigene Programme verwenden (Diese Kleinigkeiten, über die ich selber auch gestolpert bin, sind u.A. der Grund für dieses Tutorial).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_01_opengl_innerhalb_eines_qwindow">1. Tutorial 01: OpenGL innerhalb eines QWindow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Das Ziel ist erstmal einfach: ein einfarbiges Dreieck mit OpenGL in einem <code>QWindow</code> zu zeichnen.</p>
</div>
<div class="paragraph">
<p>Das sieht dann so (noch ziemlich langweilig) aus, reicht aber aus, um mehrere Seiten Tutorialtext zu füllen :-)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_01_mac.png" alt="Tutorial_01">
</div>
<div class="title">Figure 1. Ausgabe: Tutorial_01 (Mac OS Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_01">Tutorial_01</a></p>
</div>
<div class="paragraph">
<p><code>.pro</code>-Datei in Qt Creator öffnen und compilieren.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das Tutorial selbst basiert zum einen auf dem Qt Beispiel "OpenGLWindow" und auf dem Tutorial <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a>.</p>
</div>
<div class="paragraph">
<p>Beim Rendern von OpenGL Inhalten mit Qt gibt es verschiedene Möglichkeiten. Hier soll zunächst ein <code>QWindow</code> verwendet werden, welches ein natives Fenster des jeweiligen Betriebssystems kapselt. Damit kann man also ziemlich direkt und plattformnah zeichnen.</p>
</div>
<div class="sect2">
<h3 id="_qwidget_näher_betrachtet">1.1. QWidget näher betrachtet</h3>
<div class="paragraph">
<p>Um ein QWidget zu verwenden, muss man die Klasse ableiten und sollte dann einige Funktionen implementieren. Eine minimalistische Klassendeklaration sähe z.B. so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// ... other public members ...</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">// ... private members ...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das Makro <code>Q_DECL_OVERRIDE</code> wird zum Schlüsselwort <code>override</code>, wenn der Compiler dies unterstützt (C++11 erlaubt). Da das eigentlich bei Qt 5 vorausgesetzt werden kann, könnte man eigentlich immer gleich <code>override</code> schreiben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Man kann entweder mit einem rasterbasierten QPainter zeichnen, oder eben mit OpenGL. Dies legt man am besten im Constructor der Klasse fest, wie beispielsweise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QWindow</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QWindow</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Durch Aufruf der Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#setSurfaceType">setSurfaceType(QWindow::OpenGLSurface)</a> legt man fest, dass man ein natives OpenGL-Window erstellen möchte.</p>
</div>
<div class="paragraph">
<p>Das Qt Framework sendet nun zwei für uns interessante Events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QEvent::UpdateRequest</code> - wir sollten das Widget neu zeichnen</p>
</li>
<li>
<p><code>QEvent::Expose</code> - das Fenster (oder ein Teil davon) ist nun sichtbar und sollte aktualisiert werden</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Für letzteres Event existiert eine überladene Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#exposeEvent">void exposeEvent(QExposeEvent *event)</a>, welche wir implementieren:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">renderNow</span><span class="p">();</span> <span class="c1">// simply redirect call to renderNow()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wir leiten einfach die Anfrage an das Zeichnen des Bildes an eine Funktion weiter, die das macht (dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>In der Implementierung der generischen Ereignisbehandlungsfunktion <code>event()</code> picken wir uns nur das <code>UpdateRequest</code>-Ereignis heraus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
    	<span class="k">case</span> <span class="n">QEvent</span><span class="p">:</span><span class="o">:</span><span class="n">UpdateRequest</span><span class="o">:</span>
    		<span class="n">renderNow</span><span class="p">();</span> <span class="c1">// now render the image</span>
		    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	    <span class="nl">default:</span>
		    <span class="k">return</span> <span class="n">QWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Damit wäre dann unsere Aufgabe klar - eine Funktion <code>renderNow()</code> zu implementieren, die mit OpenGL zeichnet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_allgemeingültige_basisklasse_für_opengl_render_fenster">1.2. Allgemeingültige Basisklasse für OpenGL-Render-Fenster</h3>
<div class="paragraph">
<p>Die nachfolgend beschriebene Funktionalität kann man für beliebige OpenGL-Anwendungen nachnutzen, daher wird das ganze in Form einer abstrakten Basisklasse <code>OpenGLWindow</code> implementiert.</p>
</div>
<div class="paragraph">
<p>Wir erweitern die Klassendeklaration geringfügig:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">initialize</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">renderLater</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">renderNow</span><span class="p">();</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="n">QOpenGLContext</span> <span class="o">*</span><span class="n">m_context</span><span class="p">;</span> <span class="c1">// wraps the OpenGL context</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Zugriff auf die nativen OpenGL Funktionen ist in Qt in der Klasse <code>QOpenGLFunctions</code> gekapselt. Diese kann entweder als Datenmember gehalten werden, oder eben wie oben gezeigt als Implementierung vererbt werden. Da es sich ja um ein <code>OpenGLWindow</code> handelt, fühlt sich das mit der Vererbung schon richtig an.</p>
</div>
<div class="paragraph">
<p>Es gibt zwei pur virtuelle Funktionen, <code>initialize()</code> und <code>render()</code>, ohne die kein OpenGL-Programm auskommt. Daher verlangen wir von Nutzern dieser Basisklasse, dass sie diese Funktionen bereitstellen (Inhalt wird später erläutert).</p>
</div>
<div class="paragraph">
<p>Neben der Funktion <code>renderNow()</code>, welche ja oben bereits aufgerufen wurde, und deren Aufgabe das <em>sofortige</em> OpenGL-Zeichnen ist, gibt es noch eine weitere Funktion <code>renderLater()</code>. Deren Aufgabe ist es letztlich, einen Neu-Zeichen-Aufruf passend zum Vertical-Sync anzufordern, was letztlich dem Absenden eines <code>UpdateRequest</code>-Ereignisses in die Anwendungs-Ereignis-Schleife entspricht. Das macht die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestUpdate">requestUpdate()</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">renderLater</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Schedule an UpdateRequest event in the event loop</span>
	<span class="c1">// that will be send with the next VSync.</span>
	<span class="n">requestUpdate</span><span class="p">();</span> <span class="c1">// call public slot requestUpdate()</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Man kann sich strenggenommen die Funktion auch sparen, und direkt den Slot <code>requestUpdate()</code> aufrufen, aber die Benennung zeigt letztlich an, dass erst beim nächsten VSync gezeichnet wird.</p>
</div>
<div class="paragraph">
<p>Zur Synchronisation mit Bildwiederholraten kann man an dieser Stelle schon einmal zwei Dinge vorwegnehmen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>es wird doppelgepuffert gezeichnet</p>
</li>
<li>
<p>Qt ist standardmäßig zu konfiguriert, dass das <code>QEvent::UpdateRequest</code> immer zu einem VSync gesendet wird. Es wird natürlich bei einer Bildwiederholfrequenz von 60Hz vorausgesetzt, dass die Zeit bis zum Umschalten des Zeichenpuffers nicht mehr als ~16 ms ist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Variante mit dem Absenden des <code>UpdateRequest</code> in die Ereignisschleife hat den Vorteil, dass mehrere Aufrufe dieser Funktion (z.B. via Signal-Slot-Verbindung) innerhalb eines Sync-Zyklus (d.h. innerhalb von 16ms) letztlich zu einem Ereignis zusammengefasst werden, und so nur <em>einmal</em> je VSync gezeichnet wird. Wäre sonst ja auch eine Verschwendung von Rechenzeit.</p>
</div>
<div class="paragraph">
<p>Zuletzt sei noch auf die neuen private Membervariable <code>m_context</code> hingewiesen. Dieser Kontext kapselt letztlich den nativen OpenGL Kontext, d.h. den Zustandsautomaten, der bei OpenGL verwendet wird. Obwohl dieser dynamisch erzeugt wird, brauchen wir keinen  Destruktor, da wir über die QObject-Eltern-Beziehung auch automatisch <code>m_context</code> mit aufräumen.</p>
</div>
<div class="paragraph">
<p>Im Konstruktor initialisieren wir die Zeigervariable mit einem nullptr.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QWindow</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
	<span class="n">m_context</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QWindow</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_des_opengl_fensters">1.2.1. Initialisierung des OpenGL-Fensters</h4>
<div class="paragraph">
<p>Es gibt nun verschiedenen Möglichkeiten, das OpenGL-Zeichenfenster zu initialisieren. Man könnte das gleich im Konstruktor tun, wobei dann allerdings alle dafür benötigten Resourcen (auch eventuell Meshes/Texturen, &#8230;&#8203;) bereits initialisiert sein sollten. Für ein schnellen Anwendungsstart wäre das hinderlich. Besser ist es, dies später zu machen.</p>
</div>
<div class="paragraph">
<p>Man könnten nun eine eigene Initialisierungsfunktion implementieren, die der Nutzer der Klasse anfänglich aufruft. Oder man regelt dies beim allerersten Anzeigen des Fensters. Hier gibt es einiges an Spielraum und je nach Komplexität und Fehleranfälligkeit der Initialisierung ist die Variante mit einer expliziten Initialisierungsfunktion sicher gut.</p>
</div>
<div class="paragraph">
<p>Hier wird die Variante der Initialisierung-bei-erster-Verwendung genutzt (was nebenbei ja ein übliches Pattern bei Verwendung von Dialogen in Qt ist). Damit ist die Funktion <code>renderNow()</code> gefordert, die Initialisierung anzustoßen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">renderNow</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// only render if exposed</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isExposed</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="kt">bool</span> <span class="n">needsInitialize</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// initialize on first call</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_context</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLContext</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
		<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">requestedFormat</span><span class="p">());</span>
		<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">();</span>

		<span class="n">needsInitialize</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needsInitialize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">initializeOpenGLFunctions</span><span class="p">();</span>
		<span class="n">initialize</span><span class="p">();</span> <span class="c1">// call user code</span>
	<span class="p">}</span>

	<span class="n">render</span><span class="p">();</span> <span class="c1">// call user code</span>

	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">swapBuffers</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion wird einmal von <code>exposeEvent()</code> und von <code>event()</code> aufgerufen. In beiden Fällen sollte nur gezeichnet werden, wenn das Fenster tatsächlich sichtbar ist. Daher wird über die Funtion <code>isExposed()</code> zunächst geprüft, ob es überhaupt zu sehen ist. Wenn nicht, dann raus.</p>
</div>
<div class="paragraph">
<p>Jetzt kommt die oben angesprochene Initialisierung-bei-erster-Benutzung. Zuerst wird das <code>QOpenGLContext</code> Objekt erstellt. Als nächstes werden verschiedene OpenGL-spezifische Anforderungen gesetzt, wobei die im QWindow-gesetzten Formate an den QOpenGLContext übergeben werden.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestedFormat">requestedFormat()</a> liefert das für das <code>QWindow</code> eingestellte Format der Oberfläche (<code>QSurfaceFormat</code> zurück. Dieses enthält Einstellungen zu den Farb- und Tiefenpuffern, und auch zum Antialiasing des OpenGL-Renderes.</p>
</div>
<div class="paragraph">
<p>Zum Zeitpunkt der Initialisierung des OpenGL-Context muss also dieses Format bereits für das QWindow festgelegt worden sein, d.h. <em>bevor</em> das erste Mal <code>show()</code> für das OpenGLWindow aufgerufen wird.</p>
</div>
<div class="paragraph">
<p>Wenn man diese Fehlerquelle vermeiden will, muss man die Initialisierung unter Anforderung des gewünschten <code>QSurfaceFormat</code> tatsächlich in eine spezielle Funktion verschieben.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Mit dem Aufruf von <code>m_context-&gt;create()</code> wird der OpenGL Kontext (also Zustand) erstellt, wobei die vorab gesetzten Formatparameter verwendet werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Falls man später die Formatparameter ändern möchte (z.B. Antialiasing), so muss zunächst wieder das Format im Kontextobjekt neu gesetzt werden und danach <code>create()</code> neu aufgerufen werden. Dies löscht und ersetzt dann den vorherigen Kontext.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nachdem der Kontext erzeugt wurde, stehen die wohl wichtigsten Funktionen <code>makeCurrent()</code> und <code>swapBuffers()</code> zur Verfügung.</p>
</div>
<div class="paragraph">
<p>Der Aufruf <code>m_context-&gt;makeCurrent(this)</code> überträgt den Inhalt des Kontext-Objekts in den OpenGL-Zustand.</p>
</div>
<div class="paragraph">
<p>Der zweite Schritt der Initialisierung besteht im Aufruf der Funktion
<a href="https://doc.qt.io/qt-5/qopenglfunctions.html#initializeOpenGLFunctions">QOpenGLFunctions::initializeOpenGLFunctions()</a>. Hierbei werden letztlich die plattformspezifischen OpenGL-Bibliotheken dynamisch eingebunden und die Funktionszeiger auf die nativen OpenGL-Funktionen (<code>glXXX...</code>) geholt.</p>
</div>
<div class="paragraph">
<p>Zuletzt wird noch die Funktion <code>initialize()</code> mit nutzerspezifischen Initialisierungen aufgerufen.</p>
</div>
<div class="paragraph">
<p>Das eigentliche Rendern der 3D Szene muss der Anwender dann in der Funktion <code>render()</code> erledigen (dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>Am Ende tauschen wir noch mittels <code>m_context-&gt;swapBuffers(this)</code> den Fensterpuffer mit dem Renderpuffer aus.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Nachdem der Fensterpuffer aktualisiert wurde, kann das Fenster beliebig auf dem Bildschirm verschoben oder sogar minimiert werden, <em>ohne</em> dass wir neu rendern müssen. Dies gilt zumindest solange, bis wir anfangen, in der Szene mit Animationen zu arbeiten. Bei Anwendungen ohne Animationen ist es deshalb sinnvoll, nicht automaisch jeden Frame neu zu rendern, wie das bei Spieleengines wie Unity/Unreal/Irrlicht etc. gemacht wird.</p>
</div>
<div class="paragraph">
<p>Falls wir dennoch animieren wollen (und wenn es nur eine weiche Kamerafahrt wird), dann sollten wir am Ende der Funktion <code>renderNow()</code> die Funktion <code>renderLater()</code> aufrufen, und so beim nächsten VSync einen neuen Aufruf erhalten. Ach ja: wenn das Fenster versteckt ist (nicht <em>exposed</em>), dann würde natürlich die Funktion schnell verlassen werden, und die Funktion <code>renderLater()</code> wird nicht aufgerufen. Damit wäre dann die Animation gestoppt. Damit sie wieder losläuft, gibt es die implementierte Ereignisfunktion <code>exposeEvent()</code>, die das Rendering wieder anstößt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Damit wäre die zentrale Basisklasse für OpenGL-Renderfenster fertig. Wir testen das jetzt mit dem ganz am Anfang erwähnten primitiven Dreiecksbeispiel.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementierung_eines_konkreten_renderfensters">1.3. Implementierung eines konkreten Renderfensters</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vor der Lektüre diese Abschnitts sollte man den Tutorialteil <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a> überflogen haben (oder sich zumindest soweit mit OpenGL auskennen).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das konkrete Renderfenster heißt in diesem Beispiel <code>TriangleWindow</code> mit der Headerdatei <code>TriangleWindow.h</code>. Die Klassendeklaration ist recht kurz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/*	This is the window that shows the triangle.
	We derive from our OpenGLWindow base class and implement the
	virtual initialize() and render() functions.
*/</span>
<span class="k">class</span> <span class="nc">TriangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">TriangleWindow</span><span class="p">();</span>
	<span class="o">~</span><span class="n">TriangleWindow</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">initialize</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="c1">// Wraps an OpenGL VertexArrayObject (VAO)</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="c1">// Vertex buffer (only positions now).</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vertexBufferObject</span><span class="p">;</span>

	<span class="c1">// Holds the compiled shader programs.</span>
	<span class="n">QOpenGLShaderProgram</span>		<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Interessant sind die privaten Membervariablen, die nachfolgend in der Implementierung der Klasse näher erläutert werden.</p>
</div>
<div class="sect3">
<h4 id="_shaderprogramme">1.3.1. Shaderprogramme</h4>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLShaderProgram</code> kapselt ein Shaderprogramm und bietet verschiedene Bequemlichkeitsfunktionen, die in nativen OpenGL-Aufrufe umgesetzt werden.</p>
</div>
<div class="paragraph">
<p>Zuerst wird das Objekt erstellt:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">initialize</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// this function is called once, when the window is first shown, i.e. when</span>
	<span class="c1">// the the window content is first rendereds</span>

	<span class="c1">// build and compile our shader program</span>
	<span class="c1">// ------------------------------------</span>

	<span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLShaderProgram</span><span class="p">();</span>

    <span class="p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht in etwa den folgenden OpenGL-Befehlen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
<span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt nun eine ganze Reihe von Möglichkeiten, Shaderprogramme hinzuzufügen. Für das einfache Dreieck brauchen wir nur ein Vertex-Shader und ein Fragment-Shaderprogramme. Die Implementierungen dieser Shader sind in zwei Dateien abgelegt:</p>
</div>
<div class="listingblock">
<div class="title">Vertex-Shader: shader/pass_through.vert</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// vertex shader</span>

<span class="c1">// input:  attribute named 'position' with 3 floats per vertex</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Fragment-Shader: shaders/uniform_color.frag</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// fragment shader</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>  <span class="c1">// output: fertiger Farbwert als rgb-Wert</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Vertexshader schiebt die Vertexkoordinaten (als vec3) einfach als vec4 ohne jede Transformation raus. Und der Fragmentationshader gibt einfach nur die gleiche Farbe (dunkles Rot) aus.</p>
</div>
<div class="sect4">
<h5 id="_compilieren_und_linken_von_shaderprogrammen">Compilieren und Linken von Shaderprogrammen</h5>
<div class="paragraph">
<p>Die nächsten Zeilen in der <code>initialize()</code> Funktion übersetzen die Shaderprogramme und linken die Programme:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span>
	    <span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="s">":/shaders/pass_through.vert"</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span>
	    <span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span> <span class="s">":/shaders/uniform_color.frag"</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Fragment shader errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">())</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Shader linker errors :</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt mehrere überladene Funktionen <code>addShaderFromSourceFile()</code> in der Klasse <a href="https://doc.qt.io/qt-5/qopenglshaderprogram.html">QOpenGLShaderProgram</a>, hier wird die Variante mit Übernahme eines Dateinamens verwendet. Die Dateien sind in einer <code>.qrc</code> Resourcendatei referenziert und daher über die Resourcenpfade <code>:/shaders/...</code> angeben. Wichtig ist die Angabe des Typs des Shaderprogramms, hier <code>QOpenGLShader::Vertex</code> und <code>QOpenGLShader::Fragment</code>.</p>
</div>
<div class="paragraph">
<p>Erfolg oder Fehler wird über den Rückgabecode signalisiert. Das Thema Fehlerbehandlung wird aber in einem späteren Tutorial noch einmal aufgegriffen.</p>
</div>
<div class="paragraph">
<p>Letzter Schritt ist das Linken der Shaderprogramme, d.h. das Verknüpfen selbstdefinierter Variablen (Kommunikation zwischen Shaderprogrammen).</p>
</div>
<div class="paragraph">
<p>Die Funktionen der Klasse <code>QOpenGLShaderProgram</code> kapseln letztlich OpenGL-Befehle der Art:</p>
</div>
<div class="listingblock">
<div class="title">Native OpenGL Shaderprogramm-Initialisierung</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="c1">// create the shader</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
<span class="n">vertexShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>

<span class="c1">// pass shader program in C string</span>
<span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// compile the shader</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>

<span class="c1">// check success of compilation</span>
<span class="kt">int</span>  <span class="n">success</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>

<span class="c1">// print out an error if any</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader error:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// ... same for fragment shader</span>

<span class="c1">// attach shaders to shader program</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>

<span class="c1">// and link</span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Verglichen damit ist die Qt Variante mit "etwas" weniger Tippaufwand verbunden.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_vertex_buffer_objekte_vbo_und_vertex_array_objekte_vba">1.3.2. Vertex-Buffer-Objekte (VBO) und Vertex-Array-Objekte (VBA)</h4>
<div class="paragraph">
<p>Nachdem das Shaderprogramm fertig ist, erstellen wir zunächst ein Vertexpufferobjekt mit den Koordinaten des Dreiecks. Danach werden dann die Zuordnungen der Vertexdaten zu Attributen festgelegt. Und damit man diese Zuordnungen nicht immer wieder neu machen muss, merkt man sich diese in einem VertexArrayObject (VBA). Auf den ersten Blick ist das alles ganz schön kompliziert, daher machen wir das am Besten am Beispiel.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Vertexpufferobjekte (engl. <em>Vertex Buffer Objects (VBO)</em>) beinhalten letztlich die Daten, die an den Vertex-Shader gesendet werden. Aus Sicht von OpenGL müssen diese Objekte erst erstellt werden, dann gebunden werden (d.h. nachfolgende OpenGL-Befehle beziehen sich auf den Puffer), und dann wieder freigegeben werden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
		 <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
		 <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>
	<span class="p">};</span>

	<span class="c1">// create a new buffer for the vertices</span>
	<span class="n">m_vertexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="p">);</span> <span class="c1">// VBO</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span> <span class="c1">// create underlying OpenGL object</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span> <span class="c1">// must be called before allocate</span>

	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// set it active in the context, so that we can write to it</span>
	<span class="c1">// int bufSize = sizeof(vertices) = 9 * sizeof(float) = 9*4 = 36 bytes</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// copy data into buffer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im obigen Quelltext wird zunächst ein statisches Array mit 9 floats (3 x 3 Vektoren) definiert. Z-Koordinate ist jeweils 0. Nun erstellen wir ein neues VertexBufferObject vom Typ <code>QOpenGLBuffer::VertexBuffer</code>. Der Aufruf von <code>create()</code> erstellt das Objekt selbst und entspricht in etwa dem OpenGL-Aufruf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann wird dem QOpenGLBuffer-Pufferobjekt noch die geplante Zugriffsart via <code>setUsagePattern()</code> mitgeteilt. Dies führt keinen OpenGL Aufruf aus, sondern es wird sich dieses Attribute für später gemerkt.</p>
</div>
<div class="paragraph">
<p>Mit dem Aufruf von <code>bind()</code> wird dieses VBO als Aktiv im OpenGL-Kontext gesetzt, d.h. nachfolgende Funktionsaufrufe mit Bezug auf VBOs beziehen sich auf unser erstelltes VBO. Dies entspricht dem OpenGL-Aufruf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zuletzt werden die Daten im Aufruf von <code>allocate()</code> in den Puffer kopiert. Dies entspricht in etwa einem memcpy-Befehl, d.h. Quelladresse des Puffers wird übergeben und Länge in Bytes as zweites Argument. In diesem Fall sind es 9 floats, d.h. 9*4=36 Bytes. Dies entspricht dem OpenGL-Befehl:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier wird der vorab gesetzte Verwendungstyp (usagePattern) verwendet. Deshalb ist es wichtig, <code>setUsagePattern()</code> immer <em>vor</em> <code>allocate()</code> aufzurufen.</p>
</div>
<div class="paragraph">
<p>Der Puffer ist nun gebunden und man könnte nun die Vertex-Daten mit den Eingangsparametern im Shaderprogramm verknüpfen. Da wir dies nicht jedesmal vorm Zeichnen erneut machen wollen, verwenden wir ein VertexArrayObject (VBA), welches letztlich so etwas wie ein Container für derartige Verknüpfungen darstellt. Man kann sich so ein VBA wie eine Aufzeichnung der nachfolgenden Verknüpfungsbefehle vorstellen, wobei der jeweils aktive Vertexpuffer und die verknüpften Variablen kollektiv gespeichert werden. Später beim eigentlichen Zeichnen muss man nur noch das VBA einbinden, welches unter der Haube dann alle aufgezeichneten Verknüpfungen abspielt und so den OpenGL-Zustand entsprechend wiederherstellt.</p>
</div>
<div class="paragraph">
<p>Konkret sieht das so aus:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Initialize the Vertex Array Object (VAO) to record and remember subsequent attribute assocations with</span>
	<span class="c1">// generated vertex buffer(s)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span> <span class="c1">// create underlying OpenGL object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// sets the Vertex Array Object current to the OpenGL context so it monitors attribute assignments</span>

	<span class="c1">// now all following enableAttributeArray(), disableAttributeArray() and setAttributeBuffer() calls are</span>
	<span class="c1">// "recorded" in the currently bound VBA.</span>

	<span class="c1">// Enable attribute array at layout location 0</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="c1">// This maps the data we have set in the VBO to the "position" attribute.</span>
	<span class="c1">// 0 - offset - means the "position" data starts at the begin of the memory array</span>
	<span class="c1">// 3 - size of each vertex (=vec3) - means that each position-tuple has the size of 3 floats (those are the 3 coordinates,</span>
	<span class="c1">//     mind: this is the size of GL_FLOAT, not the size in bytes!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zunächst wir das Vertex-Array-Objekt erstellt und eingebunden. Danach werden alle folgenden Aufrufe von <code>enableAttributeArray()</code> und <code>setAttributeBuffer()</code> vermerkt.</p>
</div>
<div class="paragraph">
<p>Der Befehl <code>enableAttributeArray(0)</code> aktiviert ein Attribut (bzw. Variable) im Vertex-Puffer, welches im Shaderprogramm dann mit dem layout-Index 0 angesprochen werden kann. Im Vertex-Shader dieses Beispiels (siehe oben) ist das der <em>position</em> Vektor.</p>
</div>
<div class="paragraph">
<p>Mit <code>setAttributeBuffer()</code> wird nun definiert, wo im Vertex-Buffer die Daten zu finden sind, d.h. Datentyp, Anzahl (hier 3 floats entsprechend den 3 Koordinaten) und dem Startoffset (hier 0).</p>
</div>
<div class="paragraph">
<p>Diese beiden Aufrufe entsprechen den OpenGL-Aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Damit sind alle Daten initialisiert, und die Pufferobjekte können freigegeben werden:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::initialize(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Release (unbind) all</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// not really necessary, but done for completeness</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht den OpenGL-Aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Man sieht also, dass die Qt-Klassen letztlich die nativen OpenGL-Funktionsaufrufe (mitunter ziemlich direkt) kapseln.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Die Qt API fühlt sich hier nicht ganz glücklich gewählt an. Aufrufe wie <code>m_programm-&gt;enableAttributeArray(0)</code> sugggerieren, dass hier tatsächlich Objekteigenschaften geändert werden, dabei wird tatsächlich mit dem OpenGL-Zustandsautomaten gearbeitet. Entsprechend ist bei etlichen Befehlen die Reihenfolge der Aufrufe wichtig, obgleich es bei individuell setzbaren Attributen eines Objekts eigentlich egal sein sollte, welches Attribut man zuerst setzt. Daher habe ich oben im Tutorial auch noch einmal explizit die dahinterliegenden OpenGL-Befehle angegeben.</p>
</div>
<div class="paragraph">
<p>Es ist daher empfehlenswert, dass man die Qt API nochmal in eigene Klassen einpackt, und dann eine entsprechend schlange und fehlerunanfällige API entwirft.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rendern">1.3.3. Rendern</h4>
<div class="paragraph">
<p>Das eigentliche Render erfolgt in der Funktion <code>render()</code>, die als rein virtuelle Funktion von der Basisklasse <code>OpenGLWindow</code> aufgerufen wird. Die Basisklasse prüft ja auch, ob Rendern überhaupt notwendig ist, und setzt den aktuellen OpenGL Context. Dadurch kann man in dieser Funktion direkt losrendern.</p>
</div>
<div class="paragraph">
<p>Die Implementierung ist (noch) recht selbsterklärend:</p>
</div>
<div class="listingblock">
<div class="title">Funktion: TriangleWindow::render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// this function is called for every frame to be rendered on screen</span>
	<span class="k">const</span> <span class="n">qreal</span> <span class="n">retinaScale</span> <span class="o">=</span> <span class="n">devicePixelRatio</span><span class="p">();</span> <span class="c1">// needed for Macs with retina display</span>
	<span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">()</span> <span class="o">*</span> <span class="n">retinaScale</span><span class="p">,</span> <span class="n">height</span><span class="p">()</span> <span class="o">*</span> <span class="n">retinaScale</span><span class="p">);</span>

	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="c1">// use our shader program</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// bind the vertex array object, which in turn binds the vertex buffer object and</span>
	<span class="c1">// sets the attribute buffer in the OpenGL context</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// now draw the triangles:</span>
	<span class="c1">// - GL_TRIANGLES - draw individual triangles</span>
	<span class="c1">// - 0 index of first triangle to draw</span>
	<span class="c1">// - 3 number of vertices to process</span>
	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="c1">// finally release VAO again (not really necessary, just for completeness)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die ersten drei <code>glXXX</code> Befehle sind native OpenGL-Aufrufe, und sollten eigentlich in dieser Art mehr oder weniger immer auftauchen. Die Anpassung des ViewPort (<code>glViewport(...)</code>) ist für resize-Operationen notwendig, das Löschen des Color Buffers (<code>glClear(...)</code>) auch (später werden in diesem Aufruf noch andere Puffer gelöscht werden). Die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#devicePixelRatio">devicePixelRatio()</a> ist für Bildschirme mit angepasster Skalierung interessant (vornehmlich für Macs mit Retina-Display).</p>
</div>
<div class="paragraph">
<p>Solange sich die Hintergrundfarbe (clear-color) nicht ändert, könnte man diesen Aufruf auch in die Initialisierung verschieben.</p>
</div>
<div class="paragraph">
<p>Danach kommt der interessante Teil. Es wird das Shader-Programm gebunden (<code>m_programm-&gt;bind()</code>) und danach das Vertex Array Objekt (VAO) (<code>m_vao.bind()</code>). Letzteres sorgt dafür, dass im OpenGL-Kontext auch das Vertex-Buffer-Objekt und die Attributzuordnung gesetzt werden. Damit kann dann einfach gezeichnet werden, wofür mit <code>glDrawArrays(...)</code> wieder ein nativer OpenGL-Befehl zum Einsatz kommt.</p>
</div>
<div class="paragraph">
<p>Dieser Teil des Programms sähe in nativem OpenGL-Code so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ist also ziemlich ähnlich.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resourcenfreigabe">1.3.4. Resourcenfreigabe</h4>
<div class="paragraph">
<p>Bleibt noch das Aufräumen der reservierten Resourcen im Destructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">TriangleWindow</span><span class="o">::~</span><span class="n">TriangleWindow</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// resource cleanup</span>

	<span class="c1">// since we release resources related to an OpenGL context,</span>
	<span class="c1">// we make this context current before cleaning up our resources</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="n">m_vao</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">m_program</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Da einige Resourcen dem OpenGL-Kontext des aktuellen Fenster gehören, sollte man vorher den OpenGL-Kontext "aktuell" setzen (<code>m_context-&gt;makeCurrent(this);</code>), damit diese Resourcen sicher freigegeben werden können.</p>
</div>
<div class="paragraph">
<p>Damit wäre dann die Implementierung des <code>TriangleWindow</code> komplett.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_das_hauptprogramm">1.4. Das Hauptprogramm</h3>
<div class="paragraph">
<p>Das <code>TriangleWindow</code> kann jetzt eigentlich direkt als Top-Level-Fenster verwendet werden. Allerdings ist zu beachten, dass <em>vor</em> dem ersten Anzeigen (und damit vor der OpenGL-Initialisierung und Erstellung des OpenGL-Kontext) die Oberflächeneigenschaften (<code>QSurfaceFormat</code>) zu setzen sind:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QGuiApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// Set OpenGL Version information</span>
	<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

	<span class="n">TriangleWindow</span> <span class="n">window</span><span class="p">;</span>
	<span class="c1">// Note: The format must be set before show() is called.</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das wäre dann erstmal eine Grundlage, auf der man aufbauen kann. Interessanterweise bietet Qt selbst eine Klasse an, die unserer OpenGLWindow-Klasse nicht unähnlich ist. Diese schauen wir uns in <em>Tutorial 02</em> an.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_02_alternative_die_klasse_qopenglwindow">2. Tutorial 02: Alternative: die Klasse QOpenGLWindow</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wer mit der Funktionalität des OpenGLWindows aus <em>Tutorial 01</em> zufrieden ist, kann gleich mit <em>Tutorial 03</em> weitermachen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In diesem Teil schauen wir uns die Klasse <a href="https://doc.qt.io/qt-5/qopenglwindow.html">QOpenGLWindow</a> an. Mit Hilfe dieser Klasse (die letztlich die Klasse <code>OpenGLWindow</code> aus dem <em>Tutorial 01</em> ersetzt) erstellen wir ein leicht modifiziertes Zeichenprogramm (2 Dreiecke, welche ein buntes Rechteck ergeben und via Element-Index-Puffer gezeichnet werden).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_02_linux.png" alt="Tutorial_02">
</div>
<div class="title">Figure 2. Ausgabe: Tutorial_02 (Linux/Ubuntu Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_02">Tutorial_02</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Zuerst schauen wir an, was die Klasse <code>OpenGLWindow</code> unter der Haube macht.</p>
</div>
<div class="sect2">
<h3 id="_verwendung_der_klasse">2.1. Verwendung der Klasse</h3>
<div class="paragraph">
<p>Eine interessante Eigenschaft des <code>QOpenGLWindow</code> ist die Möglichkeit, nur einen Teil des Fensters neu zu zeichnen. Das wird über die <code>UpdateBehavior</code>-Eigenschaft gesteuert. Interessant ist das eigentlich nur, wenn man mittels rasterbasiertem QPainter Teile des Bildes aktualisieren möchte. Es gibt 3 Varianten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QOpenGLWindow::NoPartialUpdate</code> - das gesamte Bild wird jedes Mal neu gezeichnet (es wird kein zusätzlicher Framebuffer erzeugt und verwendet)</p>
</li>
<li>
<p><code>QOpenGLWindow::PartialUpdateBlit</code> - man zeichnet nur einen Teil des Bildes neu, und das in einem zusätzlichen, automatisch erstellten Framebuffer. Nach Ende des Zeichnens wird einfach der neu gezeichnete Teil in den eigentlichen Framebuffer kopiert.</p>
</li>
<li>
<p><code>QOpenGLWindow::PartialUpdateBlend</code> - im Prinzip wie die 2. Varianten, nur dass diesmal der Inhalt nicht kopiert, sondern überblendet wird.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ob man die 2. oder 3. Funktion braucht, hängt sicher von der Anwendung ab. Für viele OpenGL-Anwendungen wird das vielleicht nicht notwendig sein, daher schauen wir uns hier mal Variante mit <code>QOpenGLWindow::NoPartialUpdate</code> an.</p>
</div>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLWindow</code> bietet 5 interessante virtuelle Funktionen an:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">initializeGL</span><span class="p">();</span>            <span class="c1">// initialization stuff</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintGL</span><span class="p">();</span>                 <span class="c1">// actual painting</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintOverGL</span><span class="p">();</span>             <span class="c1">// not needed for NoPartialUpdate</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">paintUnderGL</span><span class="p">();</span>            <span class="c1">// not needed for NoPartialUpdate</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>    <span class="c1">// to update anything related to view port</span>
                                        <span class="c1">// size (projection matrix etc.)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>initializeGL()</code> macht eigentlich das Gleiche, wie in Tutorial 01 die Funktion <code>initialize()</code>.</p>
</div>
<div class="paragraph">
<p>Die Funktion <code>paintGL()</code> macht das Gleiche, wie in Tutorial 01 die Funktion <code>render()</code>, d.h. hier wird das Bild mit OpenGL gezeichnet.</p>
</div>
<div class="paragraph">
<p>Die Funktionen <code>paintOverGL()</code> und <code>paintUnderGL()</code> werden im Modus <code>QOpenGLWindow::NoPartialUpdate</code> nicht benötigt.</p>
</div>
<div class="paragraph">
<p>Letztlich ist die Funktion <code>resizeGL(int w, int h)</code> nur eine Bequemlichkeitsfunktion, aufgerufen aus der <code>event()</code> Funktion für das <code>QEvent::ResizeEvent</code>. Hier kann man z.B. die Projektionsmatrix an den neuen Viewport anpassen oder sonstige Größenanpassungen vornehmen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_die_implementierung_der_klasse_qopenglwindow">2.2. Die Implementierung der Klasse QOpenGLWindow</h3>
<div class="paragraph">
<p>Um die Gemeinsamkeiten und Unterschiede zur OpenGLWindow-Klasse aus Tutorial 01 zu verstehen, schauen wir uns mal die Klassenimplementierung an. Die Quelltextschnipsel stammen aus der Qt Version 5.14, sollten aber im Vergleich zu vorherigen Versionen nicht groß verändert sein.</p>
</div>
<div class="paragraph">
<p>Wichtigster Unterschied ist schon die Vererbungshierarchie. <code>QOpenGLWindow</code> leitet von <code>QOpenGLPaintDevice</code> ab, welches hardwarebeschleunigtes Zeichnen mit dem rasterbasierten <code>QPainter</code> erlaubt. Allerdings gibt es einen kleinen Haken. Zitat aus dem Handbuch:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Antialiasing in the OpenGL paint engine is done using multisampling. Most hardware require significantly more memory to do multisampling and the resulting quality is not on par with the quality of the software paint engine. The OpenGL paint engine&#8217;s strength lies in its performance, not its visual rendering quality.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Qt Documentation 5.9 zu QOpenGLPaintDevice
</div>
</div>
<div class="paragraph">
<p>Das hat insofern Auswirkung auf das Gesamterscheinungsbild der Anwendung, wenn im OpenGL Fenster verwaschene Widgets oder Kontrollen gezeichnet werden, daneben aber klassische Widgets mit scharfen Kanten.  Man kennt das Problem vielleicht von den verwaschenen Fenstern in Windows 10, wenn dort die Anwendungen letztlich in einen Pixelpuffer  zeichnen, welcher dann als Textur in einer 3D Oberfläche interpoliert gerendert wird. Sieht meiner Meinung nach doof aus :-)</p>
</div>
<div class="paragraph">
<p>Hilfreich kann das dennoch sein, wenn man existierende Zeichenfunktionalität (basierend auf QPainter) in einem OpenGL-Widget verwenden möchte. Falls man die Funktionalität nicht braucht, bringt das PaintDevice und die dafür benötigte Funktionalität <em>etwas unnützen Overhead</em> (vor allem Speicherverbrauch) mit sich.</p>
</div>
<div class="paragraph">
<p>Schauen wir uns nun die Gemeinsamkeiten an.</p>
</div>
<div class="sect3">
<h4 id="_constructor">2.2.1. Constructor</h4>
<div class="paragraph">
<p>Der Konstruktor sieht erstmal fast genauso aus, wie der unserer <code>OpenGLWindow</code>-Klasse. abgesehen davon, dass die Argumente in die private <a href="https://en.wikipedia.org/wiki/Opaque_pointer">Pimpl</a>-Klasse weitergeleitet werden.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">QOpenGLWindow</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">UpdateBehavior</span> <span class="n">updateBehavior</span><span class="p">,</span> <span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">QPaintDeviceWindow</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="nf">QOpenGLWindowPrivate</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">updateBehavior</span><span class="p">)),</span> <span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setSurfaceType</span><span class="p">(</span><span class="n">QSurface</span><span class="o">::</span><span class="n">OpenGLSurface</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ereignisbehandlungsroutinen">2.2.2. Ereignisbehandlungsroutinen</h4>
<div class="paragraph">
<p>Interessanter sind schon die Ereignisbehandlungsroutinen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">paintEvent</span><span class="p">(</span><span class="n">QPaintEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">paintGL</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span> <span class="cm">/*event*/</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Q_D</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="p">);</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">initialize</span><span class="p">();</span>
    <span class="n">resizeGL</span><span class="p">(</span><span class="n">width</span><span class="p">(),</span> <span class="n">height</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das <code>paintEvent()</code> wird einfach an die vom Nutzer zu implementierende Funktion <code>paintGL()</code> weitergereicht. Insofern analog zu der Ereignisbehandlung im OpenGLWidget, welches auf <code>QEvent::UpdateRequest</code> wartet. Allerdings sind auf dem Weg bis zum Aufruf der <code>paintEvent()</code> Funktion etliche Zwischenschritte implementiert, bis zum Erzeugen des QPaintEvent-Objekts, welches gar nicht benötigt wird. Der Aufwand wird deutlich, wenn man sich die Aufrufkette anschaut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">QPaintDeviceWindow</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>  <span class="c1">// waits for QEvent::UpdateRequest</span>
<span class="n">QPaintDeviceWindowPrivate</span><span class="o">::</span><span class="n">handleUpdateEvent</span><span class="p">()</span>
<span class="n">QPaintDeviceWindowPrivate</span><span class="o">::</span><span class="n">doFlush</span><span class="p">()</span>  <span class="c1">// calls QPaintDeviceWindowPrivate::paint()</span>

    <span class="kt">bool</span> <span class="nf">paint</span><span class="p">(</span><span class="k">const</span> <span class="n">QRegion</span> <span class="o">&amp;</span><span class="n">region</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Q_Q</span><span class="p">(</span><span class="n">QPaintDeviceWindow</span><span class="p">);</span>
        <span class="n">QRegion</span> <span class="n">toPaint</span> <span class="o">=</span> <span class="n">region</span> <span class="o">&amp;</span> <span class="n">dirtyRegion</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">toPaint</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// Clear the region now. The overridden functions may call update().</span>
        <span class="n">dirtyRegion</span> <span class="o">-=</span> <span class="n">toPaint</span><span class="p">;</span>

        <span class="n">beginPaint</span><span class="p">(</span><span class="n">toPaint</span><span class="p">);</span> <span class="c1">// here we call QOpenGLWindowPrivate::beginPaint()</span>

        <span class="n">QPaintEvent</span> <span class="n">paintEvent</span><span class="p">(</span><span class="n">toPaint</span><span class="p">);</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">paintEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paintEvent</span><span class="p">);</span> <span class="c1">// here we call QOpenGLWindowPrivate::paintEvent()</span>

        <span class="n">endPaint</span><span class="p">();</span> <span class="c1">// here we call QOpenGLWindowPrivate::endPaint()</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternativ wird <code>paintGL()</code> noch aus der Ereignisbehandlungsroutine <code>QPaintDeviceWindow::exposeEvent()</code> aufgerufen, wobei dort direkt <code>QPaintDeviceWindowPrivate::doFlush()</code> gerufen wird. Die Funktionen <code>beginPaint()</code> und  <code>endPaint()</code> kümmern sich um den temporären Framebuffer, in dem beim UpdateBehavior <code>QOpenGLWindow::PartialUpdateBlit</code> und <code>QOpenGLWindow::PartialUpdateBlend</code> gerendert wird. Ohne diese Modi passiert in der Funktion sehr wenig.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung">2.2.3. Initialisierung</h4>
<div class="paragraph">
<p>Interessant ist noch der Initialisierungsaufruf, der in der <code>resizeEvent()</code> Ereignisbehandlungsroutine steckt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">QOpenGLWindowPrivate</span><span class="o">::</span><span class="n">initialize</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Q_Q</span><span class="p">(</span><span class="n">QOpenGLWindow</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">())</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"Attempted to initialize QOpenGLWindow without a platform window"</span><span class="p">);</span>

    <span class="n">context</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">QOpenGLContext</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setShareContext</span><span class="p">(</span><span class="n">shareContext</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">requestedFormat</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">())</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"QOpenGLWindow::beginPaint: Failed to create context"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"QOpenGLWindow::beginPaint: Failed to make context current"</span><span class="p">);</span>

    <span class="n">paintDevice</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">QOpenGLWindowPaintDevice</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updateBehavior</span> <span class="o">==</span> <span class="n">QOpenGLWindow</span><span class="o">::</span><span class="n">PartialUpdateBlit</span><span class="p">)</span>
        <span class="n">hasFboBlit</span> <span class="o">=</span> <span class="n">QOpenGLFramebufferObject</span><span class="o">::</span><span class="n">hasOpenGLFramebufferBlit</span><span class="p">();</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">initializeGL</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Eigentlich sieht die Funktion fast genauso wie der Initialisierungsteil der Funktion <code>OpenGLWindow::renderNow()</code> aus <em>Tutorial 01</em> aus. Abgesehen natürlich davon, dass noch ein <code>QOpenGLWindowPaintDevice</code> erzeugt wird.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zeichnen_mit_index_elementpuffern">2.3. Zeichnen mit Index-/Elementpuffern</h3>
<div class="paragraph">
<p>Als Erweiterung zum <em>Tutorial 01</em> soll im Anwendungsbeispiel für <code>QOpenGLWindow</code> ein Indexpuffer verwendet werden. Zwei Erweiterungen werden vorgestellt:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>interleaved Vertex-Puffer (d.h. Koordinaten und Farben zusammen in einem Puffer)</p>
</li>
<li>
<p>indexbasiertes Elementzeichnen (und den dafür benötigten Elementpuffer)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Implementierung des <code>RectangleWindow</code> ist zunächst mal fast identisch zum <code>TriangleWindow</code> aus <em>Tutorial 01</em>:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cm">/*	This is the window that shows the two triangles to form a rectangle.
	We derive from our QOpenGLWindow base class and implement the
	virtual initializeGL() and paintGL() functions.
*/</span>
<span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">RectangleWindow</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">RectangleWindow</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="c1">// Wraps an OpenGL VertexArrayObject (VAO)</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="c1">// Vertex buffer (positions and colors, interleaved storage mode).</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vertexBufferObject</span><span class="p">;</span>
	<span class="c1">// Index buffer to draw two rectangles</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_indexBufferObject</span><span class="p">;</span>

	<span class="c1">// Holds the compiled shader programs.</span>
	<span class="n">QOpenGLShaderProgram</span>		<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die wesentlichsten Erweiterungen sind:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>die Klasse erbt von <code>QOpenGLWindow</code></p>
</li>
<li>
<p>die Initialisierung erfolgt in der Funktion <code>initializeGL()</code> (vormals <code>TriangleWindow::initialize()</code>)</p>
</li>
<li>
<p>das Rendern erfolgt in der Funktion <code>paintGL()</code> (vormals <code>TriangleWindow::render()</code>)</p>
</li>
<li>
<p>es gibt eine neue Variable vom Typ <code>QOpenGLBuffer</code>, welche wir für den Indexpuffer verwenden.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_shaderprogramm">2.3.1. Shaderprogramm</h4>
<div class="paragraph">
<p>Die Initialisierung beginnt wie in <em>Tutorial 01</em> unverändert mit dem Erstellen und Compilieren des Shaderprogramms. Da diesmal Farben verwendet werden, müssen beide Shaderprogramme angepasst werden:</p>
</div>
<div class="listingblock">
<div class="title">Vertexshader "shaders/pass_through.vert"</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// vertex shader</span>

<span class="c1">// input:  attribute named 'position' with 3 floats per vertex</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt nun zwei Vertex-Attribute:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>layout location 0 = Position (als vec3 Koordinate)</p>
</li>
<li>
<p>layout location 1 = Farbe (auch als vec3, rgb Farbwerte je im Bereich 0..1)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Der Farbwert eines Vertex wird als Ausgabevariable <em>fragColor</em> einfach als vec4 weitergereicht und kommt dann, bereits fertig interpoliert, als <em>fragColor</em> im Fragmentshader an. Dort wird er unverändert ausgegeben.</p>
</div>
<div class="listingblock">
<div class="title">Fragmentshader "shaders/simple.frag"</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330 core
</span>
<span class="c1">// fragment shader</span>

<span class="n">in</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>    <span class="c1">// input: interpolated color as rgba-value</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">finalColor</span><span class="p">;</span>  <span class="c1">// output: final color value as rgba-value</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">finalColor</span> <span class="o">=</span> <span class="n">fragColor</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Laden, Compilieren und Linken der Shader im Shaderprogramm wird genauso wie in <em>Tutorial 01</em> gemacht.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_von_gemischten_vertex_puffern">2.3.2. Initialisierung von gemischten Vertex-Puffern</h4>
<div class="paragraph">
<p>Als nächstes der Vertex-Buffer erstellt. Diesmal werden nicht nur Koordinaten in den Buffer geschrieben, sondern auch Farben, und zwar abwechselnd (=<em>interleaved</em>) (siehe <a href="https://learnopengl.com/Getting-started/Hello-Triangle" class="bare">https://learnopengl.com/Getting-started/Hello-Triangle</a> für eine Erläuterung).</p>
</div>
<div class="paragraph">
<p>Es wird ein Rechteck gezeichnet, und zwar durch zwei Dreiecke. Dafür brauchen wir 4 Punkte. Der Vertexpuffer-Speicherblock soll am Ende so aussehen: <code>p0c0|p1c1|p2c2|p3c3</code>, wobei p für eine Position (vec3) und c für eine Farbe (vec3) steht. Die Daten werden zunächst in statischen Arrays separat definiert.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// set up vertex data (and buffer(s)) and configure vertex attributes</span>
<span class="c1">// ------------------------------------------------------------------</span>

<span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	 <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// top right</span>
	 <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom right</span>
	<span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom left</span>
	<span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>   <span class="c1">// top left</span>
<span class="p">};</span>

<span class="n">QColor</span> <span class="n">vertexColors</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
	<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">),</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die noch getrennten Daten werden jetzt in einen gemeinsamen Speicherbereich kopiert.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create buffer for 2 interleaved attributes: position and color, 4 vertices, 3 floats each</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">vertexBufferData</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// create new data buffer - the following memory copy stuff should</span>
<span class="c1">// be placed in some convenience class in later tutorials</span>
<span class="c1">// copy data in interleaved mode with pattern p0c0|p1c1|p2c2|p3c3</span>
<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// coordinates</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="c1">// colors</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt sicher viele andere Varianten, die Daten in der gewünschten Reihenfolge in den Speicherblock zu kopieren.</p>
</div>
<div class="paragraph">
<p>Es fällt vielleicht auf, dass der gemeinsame Pufferspeicher in einem lokal erstellen <code>std::vector</code> liegt. Das wirft die Frage nach der (benötigten) Lebensdauer für diese Pufferspeicher auf.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create a new buffer for the vertices and colors, interleaved storage</span>
<span class="n">m_vertexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">VertexBuffer</span><span class="p">);</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>

<span class="c1">// now copy buffer data over: first argument pointer to data, second argument: size in bytes</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im letzten Aufruf wird der Pufferspeicher tatsächlich <em>kopiert</em>. Der Aufruf zu <code>allocate()</code> ist sowohl Speicherreservierung im OpenGL-Puffer, als auch Kopieren der Daten (wie mit <code>memcpy</code>).</p>
</div>
<div class="paragraph">
<p>Danach wird der Vector <code>vertexBufferData</code> nicht mehr benötigt, oder könnte sogar für weitere Puffer verwendet und verändert werden.</p>
</div>
</div>
<div class="sect3">
<h4 id="_element_indexpuffer">2.3.3. Element-/Indexpuffer</h4>
<div class="paragraph">
<p>In ähnlicher Weise wird nun der Elementpuffer erstellt, allerdings gibt es eine OpenGL-Besonderheit zu beachten:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das <em>Vertex Array Object</em> verwaltet nicht nur die Attribute, sondern auch gebundene Puffer. Daher muss das VAO <em>vor</em> dem Elementpuffer gebunden werden, um dann den Zustand korrekt zu speichern.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Deshalb wird nun zuerst das VAO erstellt und gebunden (kann man auch ganz am Anfang machen)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// create and bind Vertex Array Object - must be bound *before* the element buffer is bound,</span>
<span class="c1">// because the VAO remembers and manages element buffers as well</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>und dann erst der Elementpuffer erzeugt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// note that we start from 0!</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="c1">// first triangle</span>
	<span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>    <span class="c1">// second triangle</span>
<span class="p">};</span>

<span class="c1">// create a new buffer for the indexes</span>
<span class="n">m_indexBufferObject</span> <span class="o">=</span> <span class="n">QOpenGLBuffer</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">IndexBuffer</span><span class="p">);</span> <span class="c1">// Mind: use 'IndexBuffer' here</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Qt (und auch OpenGL) unterscheidet nicht zwischen Pufferobjekten für verschiedene Aufgaben. Erst beim Binden des Puffers an den OpenGL Kontext (beispielsweise durch den Aufruf <code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO)</code>) wird die Verwendung des Puffers festgelegt.</p>
</div>
<div class="paragraph">
<p>In Qt muss man die Art des Puffers als Construktor-Argument übergeben, wobei <code>QOpenGLBuffer::VertexBuffer</code> der Standard ist. Für den Index-/Elementpuffer muss man <code>QOpenGLBuffer::IndexBuffer</code> übergeben. Der eigentliche Pufferinhalt wird wieder beim Aufruf von <code>allocate()</code> kopiert.</p>
</div>
</div>
<div class="sect3">
<h4 id="_attribute_im_gemischten_vertexarray">2.3.4. Attribute im gemischten Vertexarray</h4>
<div class="paragraph">
<p>Bei der Verwendung gemischter Vertexarrays (mehrer Attribute je Vertex) muss man dem Shaderprogramm die Speicherstruktur und die Abbildung der Attribute angeben (zur Erläuterung siehe wiederum <a href="https://learnopengl.com/Getting-started/Hello-Triangle">Hello-Triangle Tutorial</a>).</p>
</div>
<div class="paragraph">
<p>Die Syntax von <code>QOpenGLShaderProgram::setAttributeBuffer</code> entspricht im wesentlichen dem nativen OpenGL-Aufruf <code>glVertexAttribPointer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// stride = number of bytes for one vertex (with all its attributes) = 3+3 floats = 6*4 = 24 Bytes</span>
<span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>

<span class="c1">// layout location 0 - vec3 with coordinates</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>

<span class="c1">// layout location 1 - vec3 with colors</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">colorOffset</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">colorOffset</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wie gesagt, für die korrekte Komposition des VAO es ist lediglich die Reihenfolge des Bindens und der <code>setAttributeBuffer()</code>-Aufrufe wichtig. Man könnte also auch die Puffer erst erstellen und befüllen und zum Schluss die folgenden Aufrufe in der geforderten Reihenfolge schreiben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span> <span class="c1">// VAO binden</span>
<span class="c1">// Puffer binden und Daten kopieren</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
<span class="n">m_indexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="p">);</span>
<span class="c1">// Attribute setzen</span>
<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(...)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In ähnlicher Art und Weise werden Bufferdaten auch aktualisiert (wird noch in einem späteren Tutorial besprochen).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_freigabe_der_puffer">2.3.5. Freigabe der Puffer</h4>
<div class="paragraph">
<p>Bei der Freigabe der Puffer ist die Reihenfolge wichtig. Damit sich das VAO den Zustand des eingebundenden Elementpuffers merkt, darf man diesen <em>nicht vor</em> Freigabe des VAO freigeben. Am Besten man gibt nur Vertexbuffer und VAO frei, und auch das nur, wenn es notwendig ist. Es wird im Beispiel auch nur der Vollständigkeithalber gemacht.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// Release (unbind) all</span>
<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Explizites Freigeben von VBO oder VAO ist eigentlich nur notwendig, wenn man mit verschiedenen VAOs arbeitet und/oder verschiedenen Shadern. Dann sollte man auf Zustand im aktuellen OpenGL-Kontext achten und bewusst OpenGL-Objekte einbinden und freigeben.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_rendern_2">2.3.6. Rendern</h4>
<div class="paragraph">
<p>Das eigentliche Zeichnen erfolgt in der <code>paintGL()</code> Funktion, welche fast genauso aussieht wie die <code>TriangleWindow::render()</code> Funktion aus <em>Tutorial 01</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="c1">// use our shader program</span>
	<span class="n">m_program</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// bind the vertex array object, which in turn binds the vertex buffer object and</span>
	<span class="c1">// sets the attribute buffer in the OpenGL context</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// For old Intel drivers you may need to explicitely re-bind the index buffer, because</span>
	<span class="c1">// these drivers do not remember the binding-state of the index/element-buffer in the VAO</span>
	<span class="c1">//	m_indexBufferObject.bind();</span>

	<span class="c1">// now draw the two triangles via index drawing</span>
	<span class="c1">// - GL_TRIANGLES - draw individual triangles via elements</span>
	<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
	<span class="c1">// finally release VAO again (not really necessary, just for completeness)</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Anpassen des Viewports (OpenGL-Aufruf <code>glViewport()</code>) kann entfallen, da das bereits in der Basisklasse gemacht wurde.</p>
</div>
<div class="paragraph">
<p>Dann folgen eigentlich die üblichen 4 Schritte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shaderprogramm binden</p>
</li>
<li>
<p>Vertex Array Objekt binden (und damit Binden des Vertex- und Elementpuffers, und setzen der Attribut-Zeiger)</p>
</li>
<li>
<p>Rendern, diesmal mit <code>glDrawElements</code> statt <code>glDrawArrays</code>, und</p>
</li>
<li>
<p>freigeben des VAO (damit danach weitere Objekte gezeichnet werden können).</p>
</li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bei einigen älteren Intel-Treibern wurde der Zustand des eingebundenen Elementpuffers noch nicht korrekt im VAO gespeichert und wiederhergestellt. Daher musste man den Index-/Elementpuffer vor dem Zeichnen immer nochmal explizit einbinden (siehe auskommentierter Quelltext).</p>
</div>
<div class="paragraph">
<p>Bei aktuellen Treibern scheint das aber kein Problem mehr zu sein (zumindest nicht unter Ubuntu).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zusammenfassung">2.4. Zusammenfassung</h3>
<div class="paragraph">
<p>Das <code>QOpenGLWindow</code> ist im Modus <code>QOpenGLWindow::NoPartialUpdate</code> eigentlich vergleichbar mit unserem minimalistischen <code>OpenGLWindow</code> aus <em>Tutorial 01</em>. Etwas Overhead ist vorhanden, allerdings sollte der in realen Anwendungen keine Rolle spielen. Es spricht also eigentlich nichts dagegen, direkt mit dem <code>QOpenGLWindow</code> anzufangen.</p>
</div>
<div class="paragraph">
<p>Für spätere Erweiterungen (Maus- und Tastatureingabebehandlung) ist dennoch eine von <code>QOpenGLWindow</code> abgeleitete Klasse nötig. Wenn man also die zusätzlichen Funktionen (QPainter-Zeichnen, Buffer-Blenden etc.) von <code>QOpenGLWindow</code> nicht braucht, kann man auch mit dem schlanken <code>OpenGLWindow</code> aus <em>Tutorial 01</em> weitermachen.</p>
</div>
<div class="paragraph">
<p>Wie man nun ein solches QWindow-basiertes (natives) OpenGL-Fenster in eine Widgets-Anwendung integriert bekommt, beschreibt <em>Tutorial 03</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_03_renderfenster_in_einem_qdialog_eingebettet">3. Tutorial 03: Renderfenster in einem QDialog eingebettet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Teil des Tutorials geht es darum, ein QWindow-basiertes OpenGL-Renderfenster (siehe <em>Tutorial 01</em> und <em>02</em>), in eine QWidgets-Anwendung einzubetten.</p>
</div>
<div class="paragraph">
<p>Der erste Teil des Tutorials beschäftigt sich allein mit der Einbettung (und ist recht kurz). Damit das Tutorial aber noch etwas interessanter wird, gibt es im 2. Abschnitt noch zwei Interaktionsvarianten mit und ohne Animation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man könnte auch die Bequemlichkeitsklasse <code>QOpenGLWidget</code> verwenden. In <em>Tutorial 04</em> schauen wir uns an, wie diese Klasse intern funktioniert und ob es ggfs. Performancenachteile geben könnte, wenn man diese Klasse verwendet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_03_win10.png" alt="Tutorial_03">
</div>
<div class="title">Figure 3. Tutorial_03 (Windows 10 Screenshot)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_03">Tutorial_03</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_window_container_widgets">3.1. Window Container Widgets</h3>
<div class="paragraph">
<p>Die Funktion <code>QWidget::createWindowContainer</code> erstellt ein <code>QWidget</code>, welches das als Argument übergebene <code>QWindow</code> einbettet. So einfach kann&#8217;s sein:</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// *** create OpenGL window</span>

<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="n">m_rectangleWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RectangleWindow</span><span class="p">;</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>

<span class="c1">// *** create window container widget</span>

<span class="n">QWidget</span> <span class="o">*</span><span class="n">container</span> <span class="o">=</span> <span class="n">QWidget</span><span class="o">::</span><span class="n">createWindowContainer</span><span class="p">(</span><span class="n">m_rectangleWindow</span><span class="p">);</span>
<span class="n">container</span><span class="o">-&gt;</span><span class="n">setMinimumSize</span><span class="p">(</span><span class="n">QSize</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">400</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m_rectangleWindow</code> ist ein Zeiger auf die aus Tutorial 02 bekannte <code>RectangleWindow</code> Klasse. Das so erstellte Container-Widget muss natürlich noch in ein Layout gesteckt werden. Aber mehr ist eigentlich nicht zu tun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interaktion_und_synchronisation_mit_dem_zeichnen">3.2. Interaktion und Synchronisation mit dem Zeichnen</h3>
<div class="paragraph">
<p>Grundsätzlich ist folgende Aktualisierungslogik anzustreben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>OpenGL zeichnet Bild

&lt;Anwendung wartet in Ereignis-Schleife&gt;

Ein Event wird abgearbeitet, ändert für die Darstellung relevante Daten. Registriert ein "UpdateRequest" in der Ereignisschleife.

&lt;Anwendung wartet in Ereignis-Schleife&gt;

Ein Event wird abgearbeitet, ändert für die Darstellung relevante Daten. Registriert ein "UpdateRequest" in der Ereignisschleife. Dieses wird mit dem bereits existierenden "UpdateRequest" verschmolzen.

Passend zum VSync wird das UpdateRequest-Event verschickt, was zum OpenGL Rendern führt. Und wieder von vorne...</code></pre>
</div>
</div>
<div class="paragraph">
<p>D.h., das potenziell zeitaufwändige Aktualisieren der Puffer und Zeichendaten erfolgt stets dann, wenn noch auf den nächsten VSync gewartet wird. So hat man ca. 16 ms Zeit (by üblichen 60 FPS), alles Notwendige zu erledigen.</p>
</div>
<div class="sect3">
<h4 id="_einmalige_änderungen_farbwechsel_auf_knopfdruck">3.2.1. Einmalige Änderungen: Farbwechsel auf Knopfdruck</h4>
<div class="paragraph">
<p>Eine typische Anwendung, vor allem in technischen Anwendungen (d.h. nicht in Spielen), ist die diskrete Änderung der 3D Szene, sei es durch eine Kamerabewegung, Auswahl und Hervorhebung einzelner Elemente, oder Transformation der dargestellten Geometrie. Innerhalb des Qt Frameworks wird also zunächst ein Ereignis (OnClick, Maus- oder Tastatureingabe, &#8230;&#8203;) in die Ereignisschleife gelangen und dort abgearbeitet werden.</p>
</div>
<div class="paragraph">
<p>Ein Beispiel ist der "Change Color" Button im Dialog im Tutorial 03. Es gibt eine OnClick-Ereignisbehandlungsroutine:</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:TestDialog::onChangeColors()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// randomize the colors and change them in the OpenGL window</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">m_vertexColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setRgbF</span><span class="p">(</span>
	        <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">RAND_MAX</span> <span class="p">);</span>

<span class="c1">// now update the scene -&gt; this will also request an update</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">updateScene</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Membervariable <code>m_vertexColors</code> wird mit zufälligen Farbwerten befüllt. Dann wird die Funktion <code>updateScene()</code> aufgerufen.</p>
</div>
<div class="paragraph">
<p>Zum Verständnis kann man noch einmal die geänderte Klassendeklaration von <code>RectangleWindow</code> anschauen:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">....</span>

	<span class="c1">// updates the scene and requests a paint update</span>
	<span class="kt">void</span> <span class="n">updateScene</span><span class="p">();</span>

	<span class="c1">// holds the vertex colors set on next call to updateScene()</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_vertexColors</span><span class="p">;</span>

<span class="nl">private:</span>

    <span class="c1">// ....</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>			<span class="n">m_vertexBufferData</span><span class="p">;</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der im <em>Tutorial 02</em> noch als temporärer lokaler Speicherbereich verwendete Vector <code>m_vertexBufferData</code> ist jetzt eine Membervariable. Die zu verwendenden Farben sind in dem öffentlichen Vector <code>m_vertexColors</code> abgelegt.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Der Quelltext in diesem Tutorial-Beispiel ist natürlich sehr fehleranfällig und unsicher. Darauf kommt es aber nicht an und die notwendigen Fehlerprüfungen wurden der Übersichtlichkeit wegen weggelassen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Vertexfarben werden im Konstruktor mittels C++11 Initialisierungsliste initialisiert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp: Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">RectangleWindow</span><span class="o">::</span><span class="n">RectangleWindow</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_vertexColors</span><span class="p">{</span> 		<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">)</span> <span class="p">},</span>
	<span class="n">m_program</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span>
	<span class="n">m_frameCount</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die OpenGL-Initialisierung ist minimal verändert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">....</span>

<span class="c1">// resize buffer for 2 interleaved attributes: position and color, 4 vertices, 3 floats each</span>
<span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// create new data buffer - the following memory copy stuff should</span>
<span class="c1">// be placed in some convenience class in later tutorials</span>
<span class="c1">// copy data in interleaved mode with pattern p0c0|p1c1|p2c2|p3c3</span>
<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// coordinates</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>
	<span class="c1">// colors</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Vertex-Puffer wird auf die richtige Größe gebracht (und bleibt so), und wird dann wie bisher belegt, wobei diesmal die Farben aus der Membervariable <code>m_vertexColors</code> kommen. Sonst ändert sich nichts.</p>
</div>
<div class="paragraph">
<p>Wenn jetzt in der Ereignisbehandlungsroutine der "Change Color" Schaltfläche die Farben in <code>m_vertexColors</code> geändert werden, hat das keinerlei Einfluss auf das OpenGL-Zeichnen. Die neuen Werte müssen erst in den OpenGL-Vertexpuffer kopiert werden.</p>
</div>
<div class="paragraph">
<p>Das passiert in der Funktion <code>updateScene()</code> (hätte auch <code>updateColors()</code> heißen können):</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:updateScene()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">updateScene</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// for now we only update colors</span>

	<span class="c1">// first update our vertex buffer memory, but only those locations that are actually changed</span>
	<span class="kt">float</span> <span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// colors</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">redF</span><span class="p">();</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">greenF</span><span class="p">();</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">blueF</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// make this OpenGL context current</span>
	<span class="n">makeCurrent</span><span class="p">();</span>

	<span class="c1">// bind the vertex buffer</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// now copy buffer data over: first argument pointer to data, second argument: size in bytes</span>
	<span class="n">m_vertexBufferObject</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">m_vertexBufferData</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">);</span>

	<span class="c1">// and request an update</span>
	<span class="n">update</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erst wird der Puffer aktualisiert. Aber anstelle diesen komplett neu aufzubauen (und eventuell noch Speicherbereiche neu zu reservieren), verändern wir einfach nur die Farbwerte.</p>
</div>
<div class="paragraph">
<p>Danach muss der OpenGL-Vertexpuffer die Daten bekommen. Damit der OpenGL-Context stimmt, wird <code>QOpenGLWindow::makeCurrent()</code> aufgerufen. Dann wird der Vertexpuffer eingebunden und schließlich die Daten kopiert.</p>
</div>
<div class="paragraph">
<p>Ganz zuletzt wird <code>QPaintDeviceWindow::update()</code> aufgerufen (<code>QOpenGLWindow</code> ist durch Vererbung auch ein <code>QPaintDeviceWindow</code>). Dies hängt letztlich ein <code>QEvent::UpdateRequest</code> an die Ereignisliste an, wodurch beim nächsten VSync neu gezeichnet wird.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann mal eine Test-Debug-Ausgabe in die Zeichenroutine einfügen. Wenn man nun in der OnClick-Ereignisbehandlungsroutine die Funktion <code>updateScene()</code> mehrfach aufruft, wird dennoch stets nur einmal je VSync gezeichnet.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_animierte_farbänderung">3.2.2. Animierte Farbänderung</h4>
<div class="paragraph">
<p>Anstelle neue Farben sofort zu setzen, kann man diese auch animiert verändern, d.h. in jedem Frame nur ein Stück von der Ursprungsfarbe zur Zielfarbe gehen.</p>
</div>
<div class="paragraph">
<p>Man benötigt zusätzliche Membervariablen und zwei neue Funktionen:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>

    <span class="p">....</span>

	<span class="kt">void</span> <span class="n">animateColorsTo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">toColors</span><span class="p">);</span>

<span class="nl">private:</span>
	<span class="c1">// modifies the scene a bit and call updateScene() afterwards</span>
	<span class="c1">// when already in the final state, doesn't do anything</span>
	<span class="kt">void</span> <span class="n">animate</span><span class="p">();</span>

    <span class="p">....</span>

    <span class="c1">// Stores the target colors that we animate towards</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_toColors</span><span class="p">;</span>
    <span class="c1">// Stores the target colors that we animate from</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span>			<span class="n">m_fromColors</span><span class="p">;</span>
    <span class="c1">// number of frames used for the animation</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">m_frameCount</span><span class="p">;</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>animateColorsTo()</code> wird wieder durch eine Schaltfläche angestoßen. Die Implementierung überträgt nur die Daten in die Membervariablen und ruft <code>animate()</code> auf:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:animateColorsTo()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">animateColorsTo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">QColor</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">toColors</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// current colors are set to "fromColors", toColors are store in m_toColors and</span>
	<span class="c1">// animation counter is reset</span>

	<span class="n">m_fromColors</span> <span class="o">=</span> <span class="n">m_vertexColors</span><span class="p">;</span>
	<span class="n">m_toColors</span> <span class="o">=</span> <span class="n">toColors</span><span class="p">;</span>
	<span class="n">m_frameCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">animate</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Variable <code>m_frameCount</code> zählt die animierten Frames seit Beginn der Animation. In der Funktion <code>animate()</code> wird dann zwischen den Anfangsfarbwerten <code>m_fromColors</code> und Zielfarbwerten <code>m_toColors</code> linear (im HSV Farbraum) interpoliert:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:animate()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">animate</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">FRAMECOUNT</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>
	<span class="c1">// if already at framecount end, stop</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">m_frameCount</span> <span class="o">&gt;</span> <span class="n">FRAMECOUNT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="c1">// this will also stop the frame rendering</span>

	<span class="c1">// update the colors</span>
	<span class="kt">double</span> <span class="n">alpha</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">m_frameCount</span><span class="p">)</span><span class="o">/</span><span class="n">FRAMECOUNT</span><span class="p">;</span>

	<span class="c1">// linear blending in HSV space will probably look "interesting", but it's simple</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m_vertexColors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">double</span> <span class="n">fromH</span><span class="p">,</span> <span class="n">fromS</span><span class="p">,</span> <span class="n">fromV</span><span class="p">;</span>
		<span class="n">m_fromColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getHsvF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fromH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromV</span><span class="p">);</span>
		<span class="kt">double</span> <span class="n">toH</span><span class="p">,</span> <span class="n">toS</span><span class="p">,</span> <span class="n">toV</span><span class="p">;</span>
		<span class="n">m_toColors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getHsvF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">toH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">toV</span><span class="p">);</span>

		<span class="n">m_vertexColors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">QColor</span><span class="o">::</span><span class="n">fromHsvF</span><span class="p">(</span> <span class="n">toH</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromH</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">),</span>
											  <span class="n">toS</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromS</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">),</span>
											  <span class="n">toV</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">fromV</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">updateScene</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist die Abfrage nach dem Überschreiten der Animationslänge (Anzahl von Frames). Sobald das Animationsende erreicht ist, wird die Funktion sofort verlassen und es finden keine weiteren Farbanpassungen und, was vielleicht wichtiger ist, keine weiteren UpdateRequest-Events statt. Dann wartet die Anwendung wieder einfach auf Nutzerinteraktion und verbraucht keine Resourcen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Diese Art der Animation ist gekoppelt an <em>tatsächlich gezeichnete Frames</em>. Wenn das Fenster im Hintergrund ist (d.h. nicht <em>exposed</em>) wird die Ausführung des UpdateRequest-Events ausgesetzt, bis das Fenster wieder sichtbar ist. Damit wartet auch die Animation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_zusammenfassung_2">3.2.3. Zusammenfassung</h4>
<div class="paragraph">
<p>Die Einbettung eines <code>QWindow</code> in eine Widgets-Anwendung ist dank Widget-Container denkbar einfach. Und was das Zusammenspiel zwischen normalen <code>QWidget</code>-basierten Eingabeereignissen und der Aktualisierung der OpenGL-Ausgabe (synchron zur Bildwiederholfrequenz) betrifft, so sind die beiden Farbanpassungsvarianten in diesem Tutorial Beispiele, wie man das machen kann.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_04_verwendung_des_qopenglwidget">4. Tutorial 04: Verwendung des QOpenGLWidget</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Tutorialteil wird das <a href="https://doc.qt.io/qt-5/qopenglwidget.html">QOpenGLWidget</a> anstelle des <code>QOpenGLWindow</code> verwendet. Das Programm macht das Gleiche wie in <em>Tutorial 03</em> (nur etwas langsamer :-), aber dazu kommen wir gleich).</p>
</div>
<div class="paragraph">
<p>Damit der Screenshot nicht ganz genauso wie im letzten Tutorial aussieht, habe ich mal einen halbdurchsichtigen Hintergrund eingeschaltet - das geht aber mit dem bisherigen Implementierungsvarianten auch (siehe letzter Teil des Tutorials).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_04_linux.png" alt="Tutorial_04">
</div>
<div class="title">Figure 4. Tutorial_04 (Linux Screenshot, mit Transparenz)</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_04">Tutorial_04</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_was_bietet_das_qopenglwidget">4.1. Was bietet das QOpenGLWidget</h3>
<div class="paragraph">
<p>Von den ganzen Qt OpenGL-Klassen ist das <code>QOpenGLWidget</code> die mit Abstand am besten dokumentierte Klasse. Es gibt ein paar interessante Details in der Dokumentation, hier ein paar Zitate:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>All rendering happens into an OpenGL framebuffer object.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Due to being backed by a framebuffer object, the behavior of QOpenGLWidget is very similar to QOpenGLWindow with the update behavior set to PartialUpdateBlit or PartialUpdateBlend. This means that the contents are preserved between paintGL() calls so that incremental rendering is possible.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Note:</strong> Most applications do not need incremental rendering because they will render everything in the view on every paint call.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Und vielleicht am Interessantesten:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Adding a QOpenGLWidget into a window turns on OpenGL-based compositing for the entire window. In some special cases this may not be ideal, and the old QGLWidget-style behavior with a separate, native child window is desired. Desktop applications that understand the limitations of this approach (for example when it comes to overlaps, transparency, scroll views and MDI areas), can use QOpenGLWindow with QWidget::createWindowContainer(). This is a modern alternative to QGLWidget and is faster than QOpenGLWidget due to the lack of the additional composition step. It is strongly recommended to limit the usage of this approach to cases where there is no other choice. Note that this option is not suitable for most embedded and mobile platforms, and it is known to have issues on certain desktop platforms (e.g. macOS) too. The stable, cross-platform solution is always QOpenGLWidget.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Qt Documentation (5.9)
</div>
</div>
<div class="paragraph">
<p>Grundlegend: Ein OpenGL bild wird beim <code>QOpenGLWidget</code> <em>immer</em> erst in einen Buffer gerendert, und dann entsprechend der Zusammensetzungsregeln (Compositing) auf den Bildschirm gezeichnet. Das dauert natürlich entsprechend länger als direktes Zeichnen (siehe Performance-Test unten).</p>
</div>
<div class="paragraph">
<p>Der wesentliche Vorteil des gepufferten Zeichnens ist die Möglichkeit des inkrementellen Renderns. Ob man das braucht, hängt wesentlich von der eigentlichen Anwendung ab. Eigentlich ist dies nur von Belang, wenn das zu rendernde Fenster aus mehreren individuellen Teilbereichen besteht. In diesem Fall könnte man aber auch die Anwendung aus mehreren OpenGL-Fenstern zusammensetzen, in in jedem Fenster individuell zeichnen.</p>
</div>
<div class="paragraph">
<p>Die letzte Anmerkung über die Portabilität und Stabilität ist vielleicht nicht ganz unwichtig. Man kann das Ganze also von 2 Seiten betrachten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mit <code>QOpenGLWidget</code> beginnen, und beim Auftreten von Performanceproblemen wechseln,</p>
</li>
<li>
<p>mit <code>QOpenGLWindow</code> oder einer selbstgeschriebenen leichtgewichtigen Klasse wie in <em>Tutorial 01</em>, beginnen, und im Falle von Kompatibilitätsproblemen auf <code>QOpenGLWidget</code> wechseln</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hinsichtlich der Programmierschnittstelle sind die verschiedenen Klassen sich sehr ähnlich. Nachfolgend sind die einzelnen Anpassungen von <em>Tutorial 03</em> zur Verwendung von <code>QOpenGLWidget</code> aufgeführt.</p>
</div>
<div class="sect3">
<h4 id="_anpassung_der_vererbungshierarchie">4.1.1. Anpassung der Vererbungshierarchie</h4>
<div class="paragraph">
<p>Der erste Schritt ist das Austauschen der Basisklasse.</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">RectangleWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QOpenGLWidget</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">RectangleWindow</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>

    <span class="p">....</span>

<span class="nl">protected:</span>
	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="n">Q_DECL_OVERRIDE</span><span class="p">;</span>

    <span class="p">....</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Klasse <code>QOpenGLWidget</code> erbt selbst nicht von <code>QOpenGLFunctions</code>, weswegen man diese Klasse als weitere Basisklasse angeben muss (geht auch noch anders, aber so muss im Quelltext sonst nicht viel angepasst werden). Der Konstruktor nimmt, wie andere Widgets auch, ein parent-Zeiger als Argument.</p>
</div>
<div class="paragraph">
<p>Die Funktionen <code>initializeGL()</code> und  <code>paintGL()</code> sind bei <code>QOpenGLWidget</code> protected. Das war&#8217;s auch schon.</p>
</div>
</div>
<div class="sect3">
<h4 id="_initialisierung_2">4.1.2. Initialisierung</h4>
<div class="paragraph">
<p>Der Konstruktor ist entsprechend zu erweitern, sodass der <code>parent</code> Zeiger an die Basisklasse weitergereicht wird:</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">RectangleWindow</span><span class="o">::</span><span class="n">RectangleWindow</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
	<span class="n">QOpenGLWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
	<span class="n">m_vertexColors</span><span class="p">{</span> 		<span class="n">QColor</span><span class="p">(</span><span class="s">"#f6a509"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#cb2dde"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#0eeed1"</span><span class="p">),</span>
							<span class="n">QColor</span><span class="p">(</span><span class="s">"#068918"</span><span class="p">)</span> <span class="p">},</span>
	<span class="n">m_program</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span>
	<span class="n">m_frameCount</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setMinimumSize</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">400</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Da die Klasse nun ein Widget ist, kann man die minimale Größe auch gleich hier setzen.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das Setzen der Größe muss vor dem ersten Anzeigen gemacht werden, da sonst das Widget nicht sichtbar ist (und auch nicht vergrößert werden kann).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Verwendung der vererbten <code>QOpenGLFunctions</code> Funktionen verlangt auch eine Initialisierung, die muss aber durch Aufruf der Funktion in <code>initializeOpenGLFunctions()</code> in <code>initializeGL()</code> erfolgen.</p>
</div>
<div class="listingblock">
<div class="title">RectangleWidget.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">initializeOpenGLFunctions</span><span class="p">();</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Mehr ist nicht zu machen, und schon ist das <code>RectangleWindow</code> ein vollständiges Widget.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Das <code>UpdateBehavior</code> ist beim <code>QOpenGLWidget</code> standardmäßig auf <code>QOpenGLWidget::NoPartialUpdate</code> gesetzt, muss also nicht extra angepasst werden.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_einbettung_in_ein_anderes_qwidget">4.1.3. Einbettung in ein anderes QWidget</h4>
<div class="paragraph">
<p>Der Widget-Container (siehe <em>Tutorial 03</em>) kann entfallen, und die Einbettung des Widgets wird wie mit jedem anderen Widget gemacht.</p>
</div>
<div class="listingblock">
<div class="title">TestDialog.cpp:Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">....</span>

<span class="n">m_rectangleWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RectangleWindow</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="n">m_rectangleWindow</span><span class="o">-&gt;</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>

<span class="c1">// *** create the layout and insert widget container</span>

<span class="n">QVBoxLayout</span> <span class="o">*</span> <span class="n">vlay</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">setMargin</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">setSpacing</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vlay</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">m_rectangleWindow</span><span class="p">);</span>

<span class="p">....</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performance_vergleich">4.2. Performance-Vergleich</h3>
<div class="paragraph">
<p>Die spannende Frage ist, wieviel langsamer ist das <code>QOpenGLWidget</code> im Vergleich zum direkten Zeichnen via <code>QOpenGLWindow</code> oder der eigenen <code>OpenGLWindow</code> Klasse aus <em>Tutorial 01</em>?</p>
</div>
<div class="paragraph">
<p>Im direkter Vergleich zwischen <em>Tutorial 03</em> und <em>Tutorial 04</em> fällt sofort auffällt auf, dass das Resize-Verhalten unterschiedlich ist. Es gibt eine merkliche Verzögerung bei der Größenänderung eines Widgets (sowohl unter Windows, als auch auf anderen Plattformen) und auch, wenn die Programme im Releasemodus kompiliert sind.</p>
</div>
<div class="paragraph">
<p>Da in diesen Testfällen nicht gerendert wird, liegt der Unterschied nur allein in der Widget-Compositing-Funktionalität im <code>QOpenGLWidget</code>.</p>
</div>
<div class="paragraph">
<p>Bei einem kleinen Benchmarktest (ca. 30 Sekunden lang mit dem Mauszeiger die Fenstergröße verändern, dabei die Anzahl der paintEvents() aufzeichnen und dann durch die Laufzeit teilen) kommt man auf:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>25 Fensteraktualisierungen/Sekunde bei der Variante mit <code>QOpenGLWindow</code>, und</p>
</li>
<li>
<p>15 Fensteraktualisierungen/Sekunde bei der Variante mit <code>QOpenGLWidget</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Das wohlgemerkt ohne OpenGL Zeichenaufrufe.</p>
</div>
<div class="paragraph">
<p>Interessant wird es, wenn man OpenGL-Animationen dazuschaltet. Dies kann man bei den Beispielen ganz einfach machen, wenn man die Frames für die Farbanimation von 120 auf, ca. 800 ändert. Dann läuft die Animation nach Klick auf "Animate Colors" ein paar Sekunden länger und man kann den CPU Overhead testen.</p>
</div>
<div class="paragraph">
<p>Bei beiden Varianten dauert die Animation exakt gleich lang, da jeweils mit nahezu 60 Frames pro Sekunde gerendert wird (bei mir zumindest).</p>
</div>
<div class="paragraph">
<p>Allerdings zeigen beide Varianten unterschiedliche CPU Auslastungen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>2.4% (single-core) CPU Load bei der Variante mit <code>QOpenGLWindow</code>, und</p>
</li>
<li>
<p>7.9% (single-core) CPU Load bei der Variante mit <code>QOpenGLWidget</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ein Unterschied ist da, aber sicher nicht der Rede wert. Da dürfte der optimische Verzögerungseffekt beim Vergrößern/Verkleinern eines Fensters während der Animation eher noch stören.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transparenz">4.3. Transparenz</h3>
<div class="paragraph">
<p>Wie schon im Screenshot zu sehen, kann man auch halb-transparente Widgetanwendungen bauen, oder auch Anwendungen mit recht unregelmäßigen Formen.</p>
</div>
<div class="sect3">
<h4 id="_mit_qopenglwidget">4.3.1. Mit QOpenGLWidget</h4>
<div class="paragraph">
<p>Bei Verwendung des <code>QOpenGLWidgets</code> ist das recht einfach. Zunächst gibt man dem obersten Widget das Attribut <code>Qt::WA_TranslucentBackground</code>. Wer keine Titelleiste und keine Rahmen um das Fenster haben möchte, muss dem obersten Widget auch noch die Eigenschaft <code>Qt::FramelessWindowHint</code> geben, also z.B.:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="n">TestDialog</span> <span class="n">dlg</span><span class="p">;</span>
	<span class="c1">// transparent window</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">WA_TranslucentBackground</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="c1">// no frame and flags.</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">setWindowFlag</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">FramelessWindowHint</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">dlg</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In der eigentlichen Zeichenfunktion muss man nur noch die Hintergrundfarbe auf Transparent umstellen (zumindest einen Alpha-Wert &lt; 1):</p>
</div>
<div class="listingblock">
<div class="title">RectangleWindow.cpp:paintGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">RectangleWindow</span><span class="o">::</span><span class="n">paintGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// fully transparent</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

	<span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Normalerweise würde man bei einem Alpha-Wert von 0 erwarten, dass der Hintergrund unverändert durchscheint, auch wenn die RGB Farbanteile der Hintergrundfarbe (clear color) irgendwelche Werte haben. Das ist aber nicht so - die Farben des Hintergrundes erscheinen etwas verblasst. Daher sollte man, wenn man wirklich den Hintergrund unverändert durchscheinen lassen möchte, die clear Color stets auf 0,0,0,0 setzen.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_mit_qwindow_basierten_opengl_renderfenstern">4.3.2. Mit QWindow-basierten OpenGL Renderfenstern</h4>
<div class="paragraph">
<p>Bei den Varianten aus <em>Tutorial 01 .. 03</em> geht Transparenz auch, allerdings mit minimal mehr Aufwand. Bei der Konfiguration des <code>QSurfaceFormat</code> muss man einen AlphaBuffer festlegen (hier gezeigt beim Beispiel aus <em>Tutorial 01</em>).</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QGuiApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// Set OpenGL Version information</span>
	<span class="n">QSurfaceFormat</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setRenderableType</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">OpenGL</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setProfile</span><span class="p">(</span><span class="n">QSurfaceFormat</span><span class="o">::</span><span class="n">CoreProfile</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setVersion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">format</span><span class="p">.</span><span class="n">setAlphaBufferSize</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

	<span class="n">TriangleWindow</span> <span class="n">window</span><span class="p">;</span>
	<span class="c1">// Note: The format must be set before show() is called.</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFormat</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">);</span>
	<span class="n">window</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
	<span class="n">window</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">FramelessWindowHint</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In der Render-Funktion muss man noch Alphablending einschalten, hier gezeigt am Beispiel aus <em>Tutorial 01</em>.</p>
</div>
<div class="listingblock">
<div class="title">TriangleWindow.cpp:render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">TriangleWindow</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>

	<span class="c1">// Set the transparency to the scene to use the transparency of the fragment shader</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_BLEND</span><span class="p">);</span>
	<span class="n">glBlendFunc</span><span class="p">(</span><span class="n">GL_SRC_ALPHA</span><span class="p">,</span> <span class="n">GL_ONE_MINUS_SRC_ALPHA</span><span class="p">);</span>

	<span class="c1">// set the background color = clear color</span>
	<span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>

    <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial_05_maus_und_tastatureingaben">5. Tutorial 05: Maus- und Tastatureingaben</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In diesem Tutorial geht es primär um Maus- und Tastatureingaben. Und damit das irgendwie Sinn macht, brauchen wir ein (schön großes) 3D Modell, und deshalb ist dieses Tutorial auch <em>sehr sehr lang</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_linux.png" alt="Tutorial_05">
</div>
<div class="title">Figure 5. Tutorial_05 (Linux Screenshot), "Die Welt aus 10000 und einer Box"</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Quelltext für dieses Tutorial liegt im github repo:  <a href="https://github.com/ghorwin/OpenGLWithQt-Tutorial/tree/master/code/Tutorial_05">Tutorial_05</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In diesem Tutorial werden viele neue Dinge verwendet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>zwei Modelle (eins für die Boxen und eins für das Gitter), nebst dazugehörigen, unterschiedlichen Shaderprogrammen (das vom Gitter verwendet in die Tiefe abgeblendete Farben)</p>
</li>
<li>
<p>Tiefenpuffer, sodass Gitterlinien/Boxen korrekt vor/hintereinander gezeichnet werden</p>
</li>
<li>
<p>Model2World und World2View-Matrizen (mit perspektivischer Projektion)</p>
</li>
<li>
<p>Shaderprogramme und Renderobjekte (bzw. Objektgruppen) sind in Klassen zusammengefasst, wodurch der Quelltext deutlich übersichtlicher wird</p>
</li>
<li>
<p>eine Maus+Tastatursteuerung (WASDQE + Mauslook, incl. Shift-Langssam-Bewege-Modus) ist integriert</p>
</li>
<li>
<p>und das Ganze wieder mit dem Schwerpunkt: Rendern nur wenn notwendig (Akku sparen!)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_überblick">5.1. Überblick</h3>
<div class="paragraph">
<p>Das Tutorial ist sehr lang, und der Quelltext entsprechend auch. Daher gehen wir in diesem Tutorial schrittweise vor. Die gezeigten Quelltextausschnitte stimmen daher nicht immer 100% mit dem finalen Quelltext überein (ich hab da aus didaktischen Gründen immer mal was weggelassen).</p>
</div>
<div class="paragraph">
<p>Folgende Implementierungsschritte werden besprochen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Anpassung der Klasse <code>OpenGLWindow</code> an die in <code>QOpenGLWidget</code> bzw. <code>QOpenGLWindow</code> verwendeten Funktionsnamen</p>
</li>
<li>
<p>Vorstellung der Klasse <code>SceneView</code>, die das bisherige <code>TriangleWindow</code> oder <code>RectangleWindow</code> ersetzt</p>
</li>
<li>
<p>Transformationsmatrizen: Model &#8594; World &#8594; Kamera &#8594; Projektion (Klassen <code>Transform3D</code> und <code>Camera</code>)</p>
</li>
<li>
<p>Kapselung der Shaderprogramme und Initialisierung und Verwendung derselben</p>
</li>
<li>
<p>Kapselung der Zeichenroutinen für das Gitterraster, Abblendeffekt am Horizont im Shader</p>
</li>
<li>
<p>Kapselung der Zeichenroutinen für die Boxen</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_fenster_basisklasse_openglwindow">5.2. Fenster-Basisklasse OpenGLWindow</h3>
<div class="paragraph">
<p>Als Grundlage für die Implementierung wird die Klasse <code>OpenGLWindow</code> aus <em>Tutorial 01</em> verwendet, allerdings etwas abgewandelt. Letztlich wird die Schnittstelle angepasst, um ungefähr der des <code>QOpenGLWidget</code> zu entsprechend:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">OpenGLWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWindow</span><span class="p">,</span> <span class="k">protected</span> <span class="n">QOpenGLFunctions</span> <span class="p">{</span>
	<span class="n">Q_OBJECT</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">OpenGLWindow</span><span class="p">(</span><span class="n">QWindow</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">void</span> <span class="n">initOpenGL</span><span class="p">();</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">renderLater</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">renderNow</span><span class="p">();</span>

<span class="nl">protected:</span>
	<span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">exposeEvent</span><span class="p">(</span><span class="n">QExposeEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span> <span class="n">Q_UNUSED</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="n">Q_UNUSED</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">QOpenGLContext</span> <span class="o">*</span><span class="n">m_context</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktionen <code>initializeGL()</code> und <code>paintGL()</code> sind aus den vorangegangen Tutorials bekannt. Die Funktion <code>resizeGL()</code> ist eigentlich nur eine Bequemlichkeitsfunktion, welche aus dem Eventhandler <code>resizeEvent()</code> aufgerufen wird.</p>
</div>
<div class="paragraph">
<p>Neu ist jedoch die Funktion <code>initOpenGL()</code>, mit der die OpenGL-Initialisierung gezielt angestoßen werden kann. Normalerweise wird die Initialisierung beim ersten Anzeigen des Fensters (genaugenommen beim ersten ResizeEvent) aufgerufen. Dies kann aber für eine sinnvolle Fehlerbehandlung zu spät sein, weil dann das Fenster wahrscheinlich leer angezeigt wird. Daher ist es sinnvoll, die Funktion nach dem Erstellen des Renderfensters, aber vor Aufruf von <code>show()</code> auszuführen.</p>
</div>
<div class="paragraph">
<p>Macht man das nicht, so wird diese Funktion wie bisher automatisch beim ersten Anzeigen aufgerufen, konkret im ResizeEvent-Handler:</p>
</div>
<div class="listingblock">
<div class="title">OpenGLWindow.cpp: Funktion resizeEvent()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">OpenGLWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">QResizeEvent</span> <span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">QWindow</span><span class="o">::</span><span class="n">resizeEvent</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="c1">// initialize on first call</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_context</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
		<span class="n">initOpenGL</span><span class="p">();</span>

	<span class="n">resizeGL</span><span class="p">(</span><span class="n">width</span><span class="p">(),</span> <span class="n">height</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unabhängig von dieser Initializierungsfunktion muss man natürlich die Funktion <code>initializeGL()</code> implementieren. Alles andere in der Klasse ist altbekannt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_klasse_sceneview_die_konkrete_implementierung">5.3. Klasse SceneView - die konkrete Implementierung</h3>
<div class="sect3">
<h4 id="_klassendeklaration">5.3.1. Klassendeklaration</h4>
<div class="paragraph">
<p>Zwecks Überblick, die Klassendeklaration in Teilen. Zunächst die üblichen Verdächtigen:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">SceneView</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OpenGLWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">SceneView</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">SceneView</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

<span class="nl">protected:</span>
	<span class="kt">void</span> <span class="n">initializeGL</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">resizeGL</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">paintGL</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann kommen die Ereignisbehandlungsroutinen für die Tastatur- und Mauseingaben. Dazu gehören auch die Hilfsfunktionen <code>checkInput()</code> und <code>processInput()</code>, die im Abschnitt zur Tastatur- und Mauseingabe erklärt sind. Die Member-Variablen <code>m_keyboardMouseHandler</code> und <code>m_inputEventReceived</code> gehören auch dazu.</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">void</span> <span class="n">keyPressEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">keyReleaseEvent</span><span class="p">(</span><span class="n">QKeyEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mousePressEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mouseReleaseEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">mouseMoveEvent</span><span class="p">(</span><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">wheelEvent</span><span class="p">(</span><span class="n">QWheelEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
	<span class="kt">void</span> <span class="nf">checkInput</span><span class="p">();</span>
	<span class="kt">void</span> <span class="nf">processInput</span><span class="p">();</span>

	<span class="n">KeyboardMouseHandler</span>		<span class="n">m_keyboardMouseHandler</span><span class="p">;</span>
	<span class="kt">bool</span>						<span class="n">m_inputEventReceived</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann kommt die Funktion <code>updateWorld2ViewMatrix()</code> zur Koordinatentransformation und die dazugehörigen Member-Variablen.</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="kt">void</span> <span class="nf">updateWorld2ViewMatrix</span><span class="p">();</span>

	<span class="n">QMatrix4x4</span>					<span class="n">m_projection</span><span class="p">;</span>
	<span class="n">Transform3D</span>					<span class="n">m_transform</span><span class="p">;</span>
	<span class="n">Camera</span>						<span class="n">m_camera</span><span class="p">;</span>
	<span class="n">QMatrix4x4</span>					<span class="n">m_worldToView</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zuletzt kommen Member-Variablen, die die Shader-Programme und Zeichenobjekte kapseln (beinhalten Shader, VAO, VBO, EBO, etc.)</p>
</div>
<div class="listingblock">
<div class="title">SceneView.h, Deklaration der Klasse SceneView, fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="n">QList</span><span class="o">&lt;</span><span class="n">ShaderProgram</span><span class="o">&gt;</span>		<span class="n">m_shaderPrograms</span><span class="p">;</span>

	<span class="n">BoxObject</span>					<span class="n">m_boxObject</span><span class="p">;</span>
	<span class="n">GridObject</span>					<span class="n">m_gridObject</span><span class="p">;</span>
<span class="err">}</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Und das war&#8217;s auch schon - recht kompakt, oder?</p>
</div>
</div>
<div class="sect3">
<h4 id="_das_aktualisierungskonzept">5.3.2. Das Aktualisierungskonzept</h4>
<div class="paragraph">
<p>Erklärtes Ziel dieser OpenGL-Implementierung ist, nur dann zu rendern, wenn es wirklich notwendig ist. Also:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>wenn die Fenstergröße (Viewport) verändert wurde,</p>
</li>
<li>
<p>wenn das Fenster angezeigt/sichtbar wird (exposed),</p>
</li>
<li>
<p>wenn durch Nutzerinteraktion die Kameraposition verändert wird</p>
</li>
<li>
<p>wenn die Szene selbst transformiert wird (z.B. programmgesteuerte Animation&#8230;&#8203;)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Wenn man jetzt bei jedem Eintreffen eines solchen Ereignisses jedesmal neu zeichnen würde, wäre das mit ziemlichem Overhead verbunden. Besser ist es, beim Eintreffen eines solchen Ereignisses einfach nur ein Neuzeichnen anzufordern. Da die <code>UpdateRequest</code>-Ereignisse normalerweise mit der Bildschirmfrequenz synchronisiert sind, kann es natürlich sein, dass mehrfach hintereinander <code>UpdateRequest</code>-Events an die Eventloop angehängt werden. Dabei werden diese aber zusammengefasst und nur ein Event ausgeschickt. Es muss ja auch nur einmal je angezeigtem Frame gezeichnet werden.</p>
</div>
<div class="paragraph">
<p>Grundsätzlich muss man also nur die Funktion <a href="https://doc.qt.io/qt-5/qwindow.html#requestUpdate">QWindow::requestUpdate()</a> (oder unsere Bequemlichkeitsfunktion <code>renderLater()</code>) aufrufen, damit beim nächsten VSync wieder neu gezeichnet wird.</p>
</div>
<div class="paragraph">
<p>Leider funktionier das Verfahren im Fall des <code>ExposeEvent</code> nicht perfekt. Gerade unter Windows führt das beim Vergrößern des Fensters zu unschönen Artefakten am rechten und unteren Bildschirmrand. Daher muss man in diesem Fall tatsächlich gleich in der Ereignisbehandlungsroutine neu zeichnen und dabei den OpenGL Viewport bereits an die neue Fenstergröße anpassen (das geschieht aber bereits in <code>OpenGLWindow::exposeEvent()</code>).</p>
</div>
<div class="paragraph">
<p>Beim <code>ResizeEvent</code> ist zu beachten, dass beim Vergrößern des Fensters allerdings <em>nur</em>, wenn der Aufruf nicht zusammen mit einem <code>ExposeEvent</code> stattfindet. Daher sollte man in der Funktion <code>SceneView::resizeEvent()</code> <em>nicht</em> <code>renderLater()</code> aufrufen!</p>
</div>
<div class="paragraph">
<p>Ohne eine Aufruf von <code>renderLater()</code> im ResizeEvent-Handler, erhält man folgende Aufrufreihenfolge bei der Fenstervergrößerung:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1222 x 891
OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1224 x 892</pre>
</div>
</div>
<div class="paragraph">
<p>Ruft man stattdessen <code>renderLater()</code> auf, erhält man:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1283 x 910
SceneView::paintGL(): Rendering to: 1283 x 910
OpenGLWindow::resizeEvent()
OpenGLWindow::exposeEvent()
SceneView::paintGL(): Rendering to: 1288 x 912
SceneView::paintGL(): Rendering to: 1288 x 912</pre>
</div>
</div>
<div class="paragraph">
<p>Wie man sieht, wird jedes Mal doppelt gezeichnet, was eine deutlich spürbare Verzögerung bedeutet. Grundsätzlich hilf es zu wissen, dass:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>beim ersten Anzeigen eines Fensters immer erst ein <code>ResizeEvent</code>, gefolgt von einem <code>ExposeEvent</code> geschickt wird</p>
</li>
<li>
<p>beim Größenändern eines Fensters ebenfalls immer ein <code>ResizeEvent</code>, gefolgt von einem <code>ExposeEvent</code> geschickt wird</p>
</li>
<li>
<p>beim Minimieren und Maximieren eines Fensters nur je ein (oder auf dem Mac mehrere) <code>ExposeEvent</code> geschickt werden. Dies kann man nutzen, um eine Animation zu stoppen und beim erneuten Anzeigen (<code>isExposed() == true</code>) wieder zu starten. Dies ist aber nicht der Fokus in diesem Tutorial. Daher könnte man auch das <code>ExposeEvent</code> komplett ignorieren und <code>renderNow()</code> direkt am Ende von  <code>OpenGLWindow::resizeEvent()</code> aufrufen. So wie es aktuell implementiert ist, wird beim Minimieren und Maximieren mehrfach <code>ExposeEvent</code> mit <code>isExposed() == true</code> aufgerufen und damit wird mehrfach trotz unverändertem Viewport und unveränderte Szene gezeichnet. Das ist aber nicht weiter bemerkbar.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_verwendung_der_klasse_sceneview">5.3.3. Verwendung der Klasse <em>SceneView</em></h4>
<div class="paragraph">
<p>Die Klasse <code>SceneView</code> wird als QWindow-basierte Klasse selbst via Widget-Container in den Testdialog eingebettet (siehe <em>Tutorial 03</em>).</p>
</div>
<div class="paragraph">
<p>Bei der Analyse des Tutorialquelltextes kann man sich von außen nach innen "arbeiten":</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>main.cpp</code> - Instanziert <code>TestDialog</code></p>
</li>
<li>
<p><code>TestDialog.cpp</code> - Instanziert <code>SceneView</code> und bettet das Objekt via Window-Container ein.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Es gibt im Quelltext von <code>TestDialog.cpp</code> nur ein neues Feature: Antialiasing (siehe Diskussion dazu im letzten Kapitel dieses Tutorials).</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementierung_der_klasse_sceneview">5.3.4. Implementierung der Klasse <em>SceneView</em></h4>
<div class="paragraph">
<p>Und da wären wir auch schon bei der Implementierung des Klasse <code>SceneView</code>.</p>
</div>
<div class="paragraph">
<p>Im Konstruktor werden letztlich 3 Dinge gemacht:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>dem Tastatur/Maus-Eingabemanager werden die für uns interessanten Tasten mitgeteilt, siehe  Abschnitt "Tastatur- und Mauseingabe"</p>
</li>
<li>
<p>die beiden ShaderProgramm-Container Objekte werden erstellt und konfiguriert, siehe Abschnitt "Shaderprogramme"</p>
</li>
<li>
<p>die Kamera- und Welttransformationsmatrizen werden auf ein paar Standardwerte eingestellt, siehe Abschnitt "Transformationsmatrizen"</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp, Konstruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SceneView</span><span class="o">::</span><span class="n">SceneView</span><span class="p">()</span> <span class="o">:</span>
	<span class="n">m_inputEventReceived</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// tell keyboard handler to monitor certain keys</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_W</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_A</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_S</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_D</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Q</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_E</span><span class="p">);</span>
	<span class="n">m_keyboardMouseHandler</span><span class="p">.</span><span class="n">addRecognizedKey</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Key_Shift</span><span class="p">);</span>

	<span class="c1">// *** create scene (no OpenGL calls are being issued below, just the data structures are created.</span>

	<span class="c1">// Shaderprogram #0 : regular geometry (painting triangles via element index)</span>
	<span class="n">ShaderProgram</span> <span class="n">blocks</span><span class="p">(</span><span class="s">":/shaders/withWorldAndCamera.vert"</span><span class="p">,</span><span class="s">":/shaders/simple.frag"</span><span class="p">);</span>
	<span class="n">blocks</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">blocks</span> <span class="p">);</span>

	<span class="c1">// Shaderprogram #1 : grid (painting grid lines)</span>
	<span class="n">ShaderProgram</span> <span class="n">grid</span><span class="p">(</span><span class="s">":/shaders/grid.vert"</span><span class="p">,</span><span class="s">":/shaders/simple.frag"</span><span class="p">);</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"worldToView"</span><span class="p">);</span> <span class="c1">// mat4</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"gridColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">grid</span><span class="p">.</span><span class="n">m_uniformNames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"backColor"</span><span class="p">);</span> <span class="c1">// vec3</span>
	<span class="n">m_shaderPrograms</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">grid</span> <span class="p">);</span>

	<span class="c1">// *** initialize camera placement and model placement in the world</span>

	<span class="c1">// move objects a little bit to the back of the scene (negative z coordinates = further back)</span>
	<span class="n">m_transform</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0</span><span class="n">f</span><span class="p">);</span>
	<span class="n">m_camera</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">m_camera</span><span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">right</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Im Konstruktor werden nur Eigenschaften für die Shaderprogramme festgelegt, die eigentliche Initialisierung (OpenGL-Aufrufe) findet in <code>initializeGL()</code> statt.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Im Destruktor der Klasse werden die OpenGL-Objekte wieder freigegeben:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp, Destruktor</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">SceneView</span><span class="o">::~</span><span class="n">SceneView</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_context</span><span class="o">-&gt;</span><span class="n">makeCurrent</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ShaderProgram</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m_shaderPrograms</span><span class="p">)</span>
		<span class="n">p</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>

	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist hier, dass der OpenGL-Context für das aktuelle Fenster aktuell gesetzt wird (<code>m_context-&gt;makeCurrent(this)</code>). Damit können dann die OpenGL-Objekte freigegeben werden. Dies erfolgt in den <code>destroy()</code> Funktionen der Shaderprogramm-Wrapper-Klasse und DrawObjekt-Wrapper-Klassen.</p>
</div>
</div>
<div class="sect3">
<h4 id="_opengl_initialisierung">5.3.5. OpenGL-Initialisierung</h4>
<div class="paragraph">
<p>Die eigentlich Initialisierung der OpenGL-Objekte (Shaderprogramme und Pufferobjekte) erfolgt in <code>initializeGL()</code>:</p>
</div>
<div class="listingblock">
<div class="title">SceneView.cpp:initializeGL()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#define SHADER(x) m_shaderPrograms[x].shaderProgram()
</span>
<span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">initializeGL</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// initialize shader programs</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ShaderProgram</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">m_shaderPrograms</span><span class="p">)</span>
		<span class="n">p</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

	<span class="c1">// tell OpenGL to show only faces whose normal vector points towards us</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
	<span class="c1">// enable depth testing, important for the grid and for the drawing order of several objects</span>
	<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>

	<span class="c1">// initialize drawable objects</span>
	<span class="n">m_boxObject</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">SHADER</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">m_gridObject</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">SHADER</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dank der Kapselung der Shaderprogramm-Initialisierung in der Klasse <code>ShaderProgram</code>, und der Kapselung der Zeichenobjekt-spezifischen Initialisierung in den Objekten, ist diese Funktion sehr viel übersichtlicher als in den bisherigen Tutorials.</p>
</div>
<div class="paragraph">
<p>Das Makro <code>SHADER(x)</code> wird verwendet, um bequem auf das <code>QOpenGLShaderProgram</code> Objekt in der Wrapper-Klasse zuzugreifen.</p>
</div>
<div class="paragraph">
<p>Die beiden <code>glXXX</code> Befehle in der Mitte der Funktion schalten zwei für 3D Szenen wichtige Funktionen ein:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GL_CULL_FACE</code> - Zeichne Flächen nicht, welche mit dem "Rücken" zu uns stehen</p>
</li>
<li>
<p><code>GL_DEPTH_TEST</code> - Führe beim Zeichnen der Fragmente einen Tiefentest durch, und verwerfe weiter hintenliegende Fragmente. Das ist wichtig dafür, dass die gezeichneten Boxen das dahinterliegende Gitter überdecken. Der dafür benötigte Tiefenpuffer wird über <code>QSurfaceFormat</code> konfiguriert (<a href="https://doc.qt.io/qt-5/qsurfaceformat.html#setDepthBufferSize">QSurfaceFormat::setDepthBufferSize()</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Funktion <code>glDepthFunc(GL_LESS)</code> muss nicht aufgerufen werden, da das bei OpenGL der Standard ist.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man kann testweise mal das Flag <code>GL_DEPTH_TEST</code> nicht setzen - die etwas verwirrende Darstellung ist, nun ja, verwirrend.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tastatur_und_mauseingabe">5.4. Tastatur- und Mauseingabe</h3>
<div class="paragraph">
<p>Qt stellt in <code>QWindow</code> und <code>QWidget</code> Ereignisbehandlungsroutinen für Tastatur- und Mauseingaben zur Verfügung. Die Deklaration dieser Funktion sind oben in der <code>SceneView</code> Klassendeklaration zu sehen.</p>
</div>
<div class="paragraph">
<p>Wenn man eine Taste auf der Tastatur drückt, wird z.B. ein <code>QEvent::KeyPress</code> ausgelöst und die Memberfunktion <code>keyPressEvent(QKeyEvent *event)</code> aufgerufen. Das passiert auch, wenn man die Taste <em>gedrückt</em> hält. Unterscheiden kann man dieses durch Prüfen der Eigenschaft <code>AutoRepeat</code> (<code>QKeyEvent::isAutoRepeat()</code>).</p>
</div>
<div class="paragraph">
<p>Für die Navigation in einer 3D Umgebung hält man die Tasten (z.B. WASD oder ähnliche) längere Zeit gedrückt (d.h. über mehrere Frames hinweg). Man benötigt also einen Zustandsmanager, der sich den aktuellen Zustand der Tasten merkt.</p>
</div>
<div class="paragraph">
<p>Ein solcher "Inputmanager" hält intern also für jede (berücksichtigte) Taste einen Zustand:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nicht gedrückt</p>
</li>
<li>
<p>Gerade gedrückt</p>
</li>
<li>
<p>Wurde gedrückt</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Letzterer ist eigentlich nur dann wichtig, wenn auf einzelne Tastendrücke reagiert werden soll, während eventuell eine aufwändige Neuzeichenroutine läuft.</p>
</div>
<div class="paragraph">
<p>Zunächst müssen wir uns den Programmauflauf der Ereignisschleife und Auswertung der Tasteneingabe genauer anschauen.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_shaderprogramme_2">5.5. Shaderprogramme</h3>
<div class="paragraph">
<p>Die Verwaltung der Shaderprogramme macht Qt ja eigentlich schon durch die Klasse <code>QOpenGLShaderProgram</code>. Wenn man eine weitere Wrapper-Klasse außen herum packt, dann wird der Quelltext noch deutlich übersichtlicher. In der Deklaration der Wrapper-Klasse <code>ShaderProgram</code> findet man die gekapselte Qt Klasse wieder:</p>
</div>
<div class="listingblock">
<div class="title">ShaderProgram.h</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ShaderProgram</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ShaderProgram</span><span class="p">();</span>
	<span class="n">ShaderProgram</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">vertexShaderFilePath</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">fragmentShaderFilePath</span><span class="p">);</span>

	<span class="kt">void</span> <span class="n">create</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

	<span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgram</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_program</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// paths to shader programs, used in create()</span>
	<span class="n">QString</span>		<span class="n">m_vertexShaderFilePath</span><span class="p">;</span>
	<span class="n">QString</span>		<span class="n">m_fragmentShaderFilePath</span><span class="p">;</span>

	<span class="n">QStringList</span>	<span class="n">m_uniformNames</span><span class="p">;</span> <span class="c1">// uniform (variable) names</span>
	<span class="n">QList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>	<span class="n">m_uniformIDs</span><span class="p">;</span>   <span class="c1">// uniform IDs (resolved in create())</span>

<span class="nl">private:</span>
	<span class="n">QOpenGLShaderProgram</span>	<span class="o">*</span><span class="n">m_program</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zur Verwaltung von Shaderprogrammen gehören auch die Variablen, die man dem Vertex- und/oder Fragment-Shaderprogramm übergeben möchte (siehe Shaderprogramme in Abschnitt "Zeichenobjekte"). Die Verwendung der Klasse sieht vor, dass man erst alle Eigenschaften setzt (Resourcen-Pfade zu den Shaderprogrammen, und die uniform-Namen im Vektor <code>m_uniformNames</code>) und dann die Funktion <code>create()</code> aufruft. Die macht dann die eigentliche Initialisierung, die in den vorangegangenen Tutorials in der <code>initializeGL()</code> Funktion gemacht wurde:</p>
</div>
<div class="listingblock">
<div class="title">ShaderProgram.cpp:create()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">ShaderProgram</span><span class="o">::</span><span class="n">create</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Q_ASSERT</span><span class="p">(</span><span class="n">m_program</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">);</span>

	<span class="n">m_program</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QOpenGLShaderProgram</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">m_vertexShaderFilePath</span><span class="p">))</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Vertex shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">addShaderFromSourceFile</span><span class="p">(</span><span class="n">QOpenGLShader</span><span class="o">::</span><span class="n">Fragment</span><span class="p">,</span> <span class="n">m_fragmentShaderFilePath</span><span class="p">))</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Fragment shader errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_program</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">())</span>
		<span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Shader linker errors:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">();</span>

	<span class="n">m_uniformIDs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">uniformName</span> <span class="o">:</span> <span class="n">m_uniformNames</span><span class="p">)</span>
		<span class="n">m_uniformIDs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">m_program</span><span class="o">-&gt;</span><span class="n">uniformLocation</span><span class="p">(</span><span class="n">uniformName</span><span class="p">));</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Dank der netten Hilfsfunktionen <code>QOpenGLShaderProgram::addShaderFromSourceFile()</code> und <code>QOpenGLShaderProgram::uniformLocation()</code> ist das auch recht übersichtlich. Die Fehlerbehandlung könnte noch besser sein, aber das kann man ja schnell nachrüsten.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beim Aufruf von <code>QOpenGLShaderProgram::addShaderFromSourceFile()</code> das erste Argument beachten, welches den Typ des Shaderprogramms festlegt!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Funktion <code>uniformLocation()</code> sucht in beiden Shaderprogrammen nach <code>uniform</code> Deklarationen, also Variablen, die unabhängig von Vertex oder Fragment dem Shaderprogramm zur Verfügung stehen. Diese werden beim compilieren und linken durchnummeriert und den zu einem uniform-Variablennamen passenden Index kann man mit <code>uniformLocation()</code> ermitteln.</p>
</div>
<div class="paragraph">
<p>Bei der Verwendung des Shaders kann man dann mit <a href="https://doc.qt.io/qt-5/qopenglshaderprogram.html#setUniformValue">setUniformValue()</a> den entsprechenden Wert setzen (siehe auch Shaderprogramm-Beispiele im Abschnitt "Zeichenobjekte").</p>
</div>
<div class="paragraph">
<p>Die Shaderprogramme wissen selbst nicht, für welche Objekte sie zum Zeichnen gebraucht werden. Auch werden die Variablen (uniforms), die sie zur Funktion benötigen, meist woanders gespeichert. Daher gibt es in der Klasse nicht mehr zu tun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transformationsmatrizen_und_kamera">5.6. Transformationsmatrizen und Kamera</h3>
<div class="sect3">
<h4 id="_transformationen">5.6.1. Transformationen</h4>
<div class="paragraph">
<p>Das Thema <em>Transformationsmatrizen</em> ist in den in der Einleitung zitierten Webtutorials/Anleitungen ausreichend beschrieben. Die Format zur Transformation eines Punktes/Vektors <code>pModel</code> in den Modellkoordinaten zu den View-Koordinaten <code>pView</code> benötigt 3 Transformationsmatrizen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pView = M_projection * M_World2Camera * M_Model2World * pModel</pre>
</div>
</div>
<div class="paragraph">
<p>Dies entspricht den Schritten:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Transformation des Punktes von Modellkoordinaten in das Weltenkoordinatensystem. Dies ist bei bewegten/animierten Objekten sinnvoll, d.h. eine Objekteigenschaft. Manchmal möchte man auch die gesamte Welt transformieren, auch dafür nimmt man die Model-zu-Welt-Transformationsmatrix.</p>
</li>
<li>
<p>Transformation von Welt- zu Beobachterkoordinatensystem (Kamera). Ist eigentlich das Gleiche, jedoch ist die Kamera, deren Ausrichtung und Position modellunabhängig.</p>
</li>
<li>
<p>Projektionstransformation (othogonal, perspektivisch, &#8230;&#8203;), kann z.B. durch near/far-plane und Angle-of-View definiert werden.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Da die Objekte in Modell bzw. Weltkoordinaten definiert und verwaltet werden, sollte besser OpenGL die Transformationen durchführen (dafür ist es ja gemacht). Je nach Anzahl der zu transformierenden Objekte kann nun den objektspezifischen ersten Transformationsschritt in das Weltenkoordinatensystem auf der CPU durchführen (idealerweise parallelisiert). Die Transformation von Weltkoordinaten in die projezierte Darstellung macht dann OpenGL. Da diese Matrix für <em>alle</em> Objekte gleich ist, kann man diese auch bequem den Shaderprogrammen übergeben. D.h. die Matrix:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>M_World2View = M_Projection * M_World2Camera * M_Model2World</pre>
</div>
</div>
<div class="paragraph">
<p>wird als uniform-Variable an die Shaderprogramme übergeben. Die Transformieren dann damit hocheffizient auf der Grafikkarte alle Vertex-Koordinaten.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aktualisierung_der_world2view_matrix">5.6.2. Aktualisierung der World2View Matrix</h4>
<div class="paragraph">
<p>Die Projektionsmatrix ändert sich bei jeder Viewport-Änderung, da sich damit zumeist das Breite/Höhe-Verhältnis ändert. Sonst ändert sich diese Matrix eigentlich nie, außer vielleicht in den Benutzereinstellungen (wenn z.B. Linseneigenschaften wie Öffnungswinkel oder Zoom verändert werden).</p>
</div>
<div class="paragraph">
<p>Die Model2World-Matrix bleibt wie oben geschrieben außen vor, da objektabhängig.</p>
</div>
<div class="paragraph">
<p>Die Kameramatrix (World2Camera) ändert sich jedoch ständig während der Navigation durch die Szene. Da die Navigation am Anfang der Neuzeichenroutine ausgewertet wird, erfolgt die Neuberechnung der Matrix (falls notwendig) auch direkt vorm Neuzeichnen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es ist denkbar, dass ein MouseMove-Event mehrfach während eines Frames ausgelöst wird. Wenn man nun die Neuberechnung der Matrix daran koppelt, führt das mitunter zu unnützer Rechenarbeit. Daher ist es sinnvoller, die Berechnung erst zu Beginn des Zeichenzyklus durchzuführen.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die eigentliche Berechnung erfolgt in der Funktion <code>updateWorld2ViewMatrix</code>. Dank der Funktionalität der Matrixklasse <code>QMatrix4x4</code> eine sehr kompakte Funktion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">SceneView</span><span class="o">::</span><span class="n">updateWorld2ViewMatrix</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// transformation steps:</span>
	<span class="c1">//   model space -&gt; transform -&gt; world space</span>
	<span class="c1">//   world space -&gt; camera/eye -&gt; camera view</span>
	<span class="c1">//   camera view -&gt; projection -&gt; normalized device coordinates (NDC)</span>
	<span class="n">m_worldToView</span> <span class="o">=</span> <span class="n">m_projection</span> <span class="o">*</span> <span class="n">m_camera</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">()</span> <span class="o">*</span> <span class="n">m_transform</span><span class="p">.</span><span class="n">toMatrix</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Multiplikation mit der Modell-Transformationsmatrix (<code>m_transform</code>) ist eigentlich nicht zwingend notwendig, dient aber der Demonstration der Animationsfähigkeit (konstantes Rotieren der Welt um die y-Achse). Dazu den <code>#if 0</code> Block in <code>paintGL()</code> nach <code>#if 1</code> ändern.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_zeichenobjekte">5.7. Zeichenobjekte</h3>
<div class="paragraph">
<p>In diesem Abschnitt geht es um die Verwaltung von Zeichenobjekten. Dies ist nicht wirklich ein Qt-Thema, da diese Art von Datenmanagement in der einen oder anderen Art in jeder OpenGL-Anwendung zu finden ist. Wen also nur die Qt-spezifischen Dinge interessieren, kann dieses Kapitel gerne überspringen.</p>
</div>
<div class="sect3">
<h4 id="_effizientes_zeichnen_großer_geometrien">5.7.1. Effizientes Zeichnen großer Geometrien</h4>
<div class="paragraph">
<p>Es gibt eine wesentliche Grundregel in OpenGL:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wenn man effizient große Geometrien zeichnen möchte, dann muss man die Anzahl der <code>glDrawXXX</code> Aufrufe so klein wie möglich halten.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ein Beispiel: wenn man z.B. 2 Würfel zeichen möchte, hat man folgende Möglichkeiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>alle 12 Seiten einzeln Zeichen (12 <code>glDrawXXX</code> Aufrufe), z.B. als:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (6 Vertices)</p>
</li>
<li>
<p><code>GL_TRIANGLE_STRIP</code> (4 Vertices)</p>
</li>
<li>
<p><code>GL_QUADS</code> (4 Vertices)</p>
</li>
</ul>
</div>
</li>
<li>
<p>jeden Würfel einzeln zeichnen (2 <code>glDrawXXX</code> Aufrufe), dabei alle Seiten des Würfels zusammen zeichnen via:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (8 Vertices, 6*6 Elementindices)</p>
</li>
<li>
<p><code>GL_QUADS</code> (8 Vertices, 6*4 Elementindices)</p>
</li>
</ul>
</div>
</li>
<li>
<p>beide Würfel zusammen zeichnen (1 <code>glDrawXXX</code> Aufruf), dabei alle Seiten beider Würfels zusammen zeichnen via:</p>
<div class="ulist">
<ul>
<li>
<p><code>GL_TRIANGLES</code> (2*8 Vertices, 2*6*6 Elementindices)</p>
</li>
<li>
<p><code>GL_QUADS</code> (2*8 Vertices, 2*6*4 Elementindices)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Wenn man Objekte mit gemischten Flächenprimitiven hat (also z.B. Dreiecke und Rechtecke, oder Polygone), dann kann man entweder nach Flächentyp zusammenfassen und je Flächentyp ein <code>glDrawXXX</code> Aufruf ausführen, oder eben alles als Dreiecke behandeln und nur einen Zeichenaufruf verwenden. Kann man mal durch Profiling ausprobieren, was dann schneller ist. Der Speicherverbrauch spielt auch eine Rolle, da der Datentransfer zwischen CPU und GPU immer auch an der Geschwindigkeit der Speicheranbindung hängt.</p>
</div>
</div>
<div class="sect3">
<h4 id="_verwaltung_von_zeichenobjekten">5.7.2. Verwaltung von Zeichenobjekten</h4>
<div class="paragraph">
<p>Eine Möglichkeit, die für das Zeichnen derart gruppierter Daten benötigten Objekte, d.h. VertexArrayObject (VAO), VertexBufferObject (VBO) und ElementBufferObject (EBO), zu verwalten, ist eigene Datenhalteklassen zu verwenden. Diese sehen allgemein so aus:</p>
</div>
<div class="listingblock">
<div class="title">Deklaration einer Zeichenobjektklasse</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">DrawObject</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">DrawObject</span><span class="p">();</span>

    <span class="c1">// create native OpenGL objects</span>
    <span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">);</span>
    <span class="c1">// release native OpenGL objects</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

    <span class="c1">// actual render objects</span>
	<span class="kt">void</span> <span class="n">render</span><span class="p">();</span>

    <span class="c1">// Data members to store state</span>
    <span class="p">....</span>

    <span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vbo</span><span class="p">;</span> <span class="c1">// Vertex buffer</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_ebo</span><span class="p">;</span> <span class="c1">// Element/index buffer</span>

	<span class="c1">// other buffer objects</span>

	<span class="p">....</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die drei wichtigen Lebenszyklusphasen der Objekte sind durch die Funktionen <code>create()</code>, <code>destroy()</code> und <code>render()</code> abgebildet.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Speichermanagement bei OpenGL Objekten sollte explizit erfolgen, und nicht im Destruktor von Klassen. Es ist beim Aufräumen im Destruktor durch die automatisiert generierte Aufrufreihenfolge der einzelnen Destruktoren schwierig sicherzustellen, dass der dazugehörige OpenGL-Kontext aktiv ist. Daher empfiehlt es sich, stets eine explizite <code>destroy()</code> Funktion zu verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Am Besten wird das Datenmanagement in einer Beispielimplementierung sichtbar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_zeichenobjekt_1_gitterraster_in_x_z_ebene">5.7.3. Zeichenobjekt #1: Gitterraster in X-Z Ebene</h4>
<div class="paragraph">
<p>Beginnen wir mit einem einfachen Beispiel: Ein Gitterraster soll auf dem Bildschirm gezeichnet werden, sozusagen als "Boden". Es werden also Linien in der X-Z-Ebene (y=0) gezeichnet, wofür der Elementtyp <code>GL_LINES</code> zum Zeichnen verwendet wird.</p>
</div>
<div class="paragraph">
<p>Für jede Linie sind Start- und Endkoordinaten anzugeben, wobei die y-Koordinate eingespart werden kann.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Man muss nicht immer alle Koordinaten (x,y,z) an den Vertexshader übergeben, wenn es nicht notwendig ist.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Wir stellen also den Vertexpuffer mit folgendem Schema zusammen:</p>
</div>
<div class="paragraph">
<p><code>x1sz1sx1ez1ex2sz2sx2ez2e...</code> also jeweils x und z Koordinatentuple für je Start- (s) und Endpunkt (e) einer Linie nacheinander.</p>
</div>
<div class="paragraph">
<p>Diese Geometrieinformation wird in der Klasse <code>GridObject</code> zusammengestellt:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.h, Klassendeklaration</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">GridObject</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">destroy</span><span class="p">();</span>

	<span class="kt">void</span> <span class="n">render</span><span class="p">();</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>				<span class="n">m_bufferSize</span><span class="p">;</span>
	<span class="n">QOpenGLVertexArrayObject</span>	<span class="n">m_vao</span><span class="p">;</span>
	<span class="n">QOpenGLBuffer</span>				<span class="n">m_vbo</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Implementierung der <code>create()</code> Funktion ist das eigentlich Interessante:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:create()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">QOpenGLShaderProgram</span> <span class="o">*</span> <span class="n">shaderProgramm</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// number of lines to draw in x and z direction</span>
	<span class="c1">// width is in "space units", whatever that means for you (meters, km, nanometers...)</span>
	<span class="kt">float</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="c1">// grid is centered around origin, and expands to width/2 in -x, +x, -z and +z direction</span>

	<span class="c1">// create a temporary buffer that will contain the x-z coordinates of all grid lines</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>			<span class="n">gridVertexBufferData</span><span class="p">;</span>
	<span class="c1">// we have 2*N lines, each line requires two vertexes, with two floats (x and z coordinates) each.</span>
	<span class="n">m_bufferSize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m_bufferSize</span><span class="p">);</span>
	<span class="kt">float</span> <span class="o">*</span> <span class="n">gridVertexBufferPtr</span> <span class="o">=</span> <span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
	<span class="c1">// compute grid lines with z = const</span>
	<span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">gridVertexBufferPtr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">z</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// compute grid lines with x = const</span>
	<span class="kt">float</span> <span class="n">z1</span> <span class="o">=</span> <span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">gridVertexBufferPtr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="n">width</span><span class="o">*</span><span class="mf">0.5</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">gridVertexBufferPtr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2</span><span class="p">;</span>
	<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Im ersten Teil wird ein linearer Speicherbereich (bereitgestellt in einem <code>std::vector</code>) mit den Liniendaten gefüllt. Das Raster besteht aus Linien in X und Z Richtung (2), jeweils N Linien, und jede Linie hat einen Start- und einen Endpunkt (2) und jeder Punkt besteht aus 2 Koordinaten. Dies macht 2*N*2*2 floats (=NVertices).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Es ist ok an dieser Stelle den Speicherbereich in einem temporären Vektor anzulegen, da beim Erzeugen des OpenGL-Vertexpuffers die Daten kopiert werden und der Vektor danach nicht mehr benötigt wird. Dies ist im Falle von veränderlichen Daten (siehe BoxObjekte unten) anders.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Im zweiten Teil der Funktion werden dann wie gehabt die OpenGL-Pufferobjekte erstellt:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:create(), fortgesetzt</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">	<span class="c1">// Create Vertex Array Object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>		<span class="c1">// create Vertex Array Object</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>		<span class="c1">// and bind it</span>

	<span class="c1">// Create Vertex Buffer Object</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">setUsagePattern</span><span class="p">(</span><span class="n">QOpenGLBuffer</span><span class="o">::</span><span class="n">StaticDraw</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">vertexMemSize</span> <span class="o">=</span> <span class="n">m_bufferSize</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">gridVertexBufferData</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">vertexMemSize</span><span class="p">);</span>

	<span class="c1">// layout(location = 0) = vec2 position</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">enableAttributeArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// array with index/id 0</span>
	<span class="n">shaderProgramm</span><span class="o">-&gt;</span><span class="n">setAttributeBuffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span>
								  <span class="mi">0</span> <span class="cm">/* position/vertex offset */</span><span class="p">,</span>
								  <span class="mi">2</span> <span class="cm">/* two floats per position = vec2 */</span><span class="p">,</span>
								  <span class="mi">0</span> <span class="cm">/* vertex after vertex, no interleaving */</span><span class="p">);</span>

	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Aufrufe von <code>shaderProgramm-&gt;enableAttributeArray</code> und <code>shaderProgramm-&gt;setAttributeBuffer</code> definieren, wie der Vertexshader auf diesen Speicherbereich zugreifen soll. Deshalb muss die Funktion <code>create()</code> auch das dazugehörige Shaderprogramm als Funktionsargument erhalten.</p>
</div>
<div class="paragraph">
<p>Nachdem nun die Puffer erstellt und konfiguriert wurden, ist der Rest der Klassenimplementierung recht übersichtlich:</p>
</div>
<div class="listingblock">
<div class="title">GridObject.cpp:destroy() und render()</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">destroy</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
	<span class="n">m_vbo</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">GridObject</span><span class="o">::</span><span class="n">render</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">bind</span><span class="p">();</span>
	<span class="c1">// draw the grid lines, m_bufferSize = number of floats in buffer</span>
	<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_LINES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m_bufferSize</span><span class="p">);</span>
	<span class="n">m_vao</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Funktion <code>destroy()</code> ist sicher selbsterklärend. Und die Render-Funktion ebenso.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Beachte, dass die Funktion <code>glDrawArrays()</code> als drittes Argument die Länge des Puffers als Anzahl der Elemente vom Typ des Puffers (hier GL_FLOAT) erwartet, und <em>nicht</em> die Länge in Bytes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das Ergebnis dieses Zeichnens (mit uniformer Gitterfarbe) ist zunächst ganz nett:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_gridplain.png" alt="Raster">
</div>
<div class="title">Figure 6. Einfaches Gitterraster (einfarbig) mit sichtbarer endlicher Ausdehnung</div>
</div>
<div class="paragraph">
<p>Aber schöne wäre es, wenn das Gitter mit zunehmender Tiefe verblasst.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gitter_mit_abblendung_in_der_tiefe">5.7.4. Gitter mit Abblendung in der Tiefe</h4>
<div class="paragraph">
<p>Das Gitter sollte sich nun in weiter Ferne der Hintergrundfarbe annähern. Man könnte das zum Beispiel erreichen, wenn man die Farbe des Gitters an weiter entfernten Punkte einfärbt.</p>
</div>
<div class="paragraph">
<p>Den Vertexshader könnte man wie folgt erweitern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="c1">// GLSL version 3.3</span>
<span class="c1">// vertex shader</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">position</span><span class="p">;</span> <span class="c1">// input:  attribute with index '0'</span>
                                       <span class="c1">//         with 2 floats (x, z coords) per vertex</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">fragColor</span><span class="p">;</span>                    <span class="c1">// output: computed vertex color for shader</span>

<span class="k">const</span> <span class="kt">float</span> <span class="n">FARPLANE</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>             <span class="c1">// threshold</span>
<span class="kt">float</span> <span class="n">fragDepth</span><span class="p">;</span>                       <span class="c1">// normalized depth value</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">worldToView</span><span class="p">;</span>              <span class="c1">// parameter: the view transformation matrix</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gridColor</span><span class="p">;</span>                <span class="c1">// parameter: grid color as rgb triple</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">backColor</span><span class="p">;</span>                <span class="c1">// parameter: background color as rgb triple</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">worldToView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fragDepth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gl_Position</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">FARPLANE</span><span class="p">));</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">mix</span><span class="p">(</span><span class="n">gridColor</span><span class="p">,</span> <span class="n">backColor</span><span class="p">,</span> <span class="n">fragDepth</span><span class="p">),</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt 3 Parameter, die dem Shaderprogramm gegeben werden müssen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>worldToView</code> - Transformationsmatrix (von Weltkoordinaten zur perspektivischen Ansicht)</p>
</li>
<li>
<p><code>gridColor</code> - Farbe des Gitters</p>
</li>
<li>
<p><code>backColor</code> - Hintergrundfarbe</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die Variable <code>gl_Position</code> enthält nach der Transformation die normalisierten Koordinaten. In der Berechnung wird die zweite Komponente des Vertex-Vektors (angesprochen über <code>.y</code>) als z-Koordinate verwendet.</p>
</div>
<div class="paragraph">
<p>Für die Abblendefunktionalität ist die Entfernung des Linienstart- bzw. -endpunktes  interessant. Nun sind die z-Koordinaten dieser normalisierten Position alle sehr dicht an 1 dran. Deshalb werden sie noch skaliert (entsprechend der perspektivischen Transformationsregeln etwas wie eine Farplane). Nun kann man diese Tiefe, gespeichert in der Variable <code>fragDepth</code> nutzen, um zwischen Gitterfarbe und Hintergrundfarbe linear mit der GLSL-Funktion <code>mix()</code> zu interpolieren.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_grid_vertexshaderfade.png" alt="Gitter" width="Vertexshaderfade">
</div>
<div class="title">Figure 7. Gitterraster mit Vertex-basierter Abblendung</div>
</div>
<div class="paragraph">
<p>Das Ergebnis geht schon in die richtige Richtung, aber es gibt einen unschönen Effekt, wenn man parallel zu den Linien schaut. Die Koordinaten der Endpunkte der seitlich laufenden Linien sind sehr weit weg (in der perspektivischen Projekten), sodass beide Linienenden nahezu Hintergrundfarbe bekommen. Und da die Fragmentfarbe eine lineare Interpolation zwischen den Vertexfarben ist, verschwindet die gesamte Linie.</p>
</div>
<div class="paragraph">
<p>Das Problem lässt sich nur beheben, wenn man die Ablendfunktionalität in den Fragment-Shader steckt.</p>
</div>
<div class="paragraph">
<p>Der Vertex-Shader wird dadurch total einfach:</p>
</div>
<div class="listingblock">
<div class="title">grid.vert (Vertexshader)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="c1">// GLSL version 3.3</span>
<span class="c1">// vertex shader</span>

<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">position</span><span class="p">;</span> <span class="c1">// input:  attribute with index '0'</span>
                                       <span class="c1">//         with 2 floats (x, z coords) per vertex</span>

<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">worldToView</span><span class="p">;</span>              <span class="c1">// parameter: world to view transformation matrix</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">worldToView</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Letztlich werden nur noch die Vertex-Koordinaten transformiert und an den Shader weitergereicht. Der sieht dann so aus:</p>
</div>
<div class="listingblock">
<div class="title">grid.frag (Fragmentshader)</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c"><span class="cp">#version 330
</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">fColor</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">gridColor</span><span class="p">;</span>                <span class="c1">// parameter: grid color as rgb triple</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">backColor</span><span class="p">;</span>                <span class="c1">// parameter: background color as rgb triple</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">FARPLANE</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>            <span class="c1">// threshold</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">distanceFromCamera</span> <span class="o">=</span> <span class="p">(</span><span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">FARPLANE</span><span class="p">;</span>
  <span class="n">distanceFromCamera</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">distanceFromCamera</span><span class="p">));</span> <span class="c1">// clip to valid value range</span>
  <span class="n">fColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">mix</span><span class="p">(</span><span class="n">gridColor</span><span class="p">,</span> <span class="n">backColor</span><span class="p">,</span> <span class="n">distanceFromCamera</span><span class="p">),</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Variable <code>gl_FragCoord</code> wird für jeden einzelnen Bildpunkt von OpenGL bereitgestellt und enthält die Normalized Device Coordinates (NDC). Wenn man beachtet, dass diese Koordinaten durch Division mit w berechnet werden, dann bekommt man die originale z-Koordinate durch Multiplikation mit w. Das ganze wird dann noch mit einem Begrenzungswert (<code>FARPLANE</code>) skaliert. Falls bei der Definition des View-Frustums andere Werte für Near/Farplane verwendet werden, muss man die Formel entsprechend anpassen.</p>
</div>
<div class="paragraph">
<p>Damit sieht das Ergebnis dann wie gewünscht aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Tutorial_05_grid_fragshaderfade.png" alt="Gitter" width="Fragmentshaderfade">
</div>
<div class="title">Figure 8. Gitterraster mit Fragment-basierter Abblendung</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_antialiasing">5.8. Antialiasing</h3>
<div class="paragraph">
<p>Es gibt hier verschiedene Möglichkeiten, die wohl einfachste aus Sicht der Programmierung ist das Einschalten von Multisampling (MSAA) (siehe Erläuterung auf <a href="https://www.khronos.org/opengl/wiki/Multisampling" class="bare">https://www.khronos.org/opengl/wiki/Multisampling</a>).</p>
</div>
<div class="paragraph">
<p>Dazu muss man beim Konfigurieren des <code>QSurfaceFormat</code>-Objekts nur folgende Zeile hinzufügen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">format</span><span class="p">.</span><span class="n">setSamples</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>	<span class="c1">// enable multisampling (antialiasing)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Multisampling braucht mehr Grafikkartenspeicher und ist durch das mehrfache Samplen von Pixeln/Fragmenten natürlich langsamer. Daher gibt es auch die Möglichkeit, Antialiasing in das Shaderprogramm einzubauen.</p>
</div>
<div class="paragraph">
<p>TODO : Antialiased-Shader</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1.0<br>
Last updated 2020-03-25 20:37:20 +0100
</div>
</div>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</body>
</html>